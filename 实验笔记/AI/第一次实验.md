## AStar

### 启发式函数
在这次的实验中，使用的启发式函数为曼哈顿距离
![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240505151454.png)

==Admissible==
易知，从起点出发到达终点的最短距离为横纵坐标距离之和
所以最短路径的天数一定$\geq$曼哈顿距离
所以满足Admissible

==Consistent==
由于一次移动，曼哈顿距离最多减小1（一次移动代价为1），即$h(u)\leq h(v) + c(u\rightarrow v)$，所以满足Consistent

### 算法主要思路

==A\*搜索主体==如下，维护两个表
**open_list**存储已经搜索到但未拓展的节点，使用优先队列存储，按f排序
**close_list**存储已经探索完全的节点
其中每个节点为一个状态，用x , y , t唯一标识（将相同x，y，不同t的节点视作不同状态）
由于启发式满足consistent，所以可以使用图搜索，即进入close_list的节点不会再放入open_list
整个搜索过程类似Dijkstra

![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240505152521.png)

==cellCanReach函数==用来判断当前节点可以到达的所有节点![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240505153300.png)
==isInPriorityQueue函数==用来判断待添加节点是否在open_list中，如果在，则更新open_list的对应节点，如果不在，则将其添加进open_list
![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240505153534.png)

==节点结构==如下：
![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240505154112.png)

==修改CompareF==
![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240505155518.png)
将$\gt修改为\geq，使得在相同f的情况下,后进入open\_list的节点位列队列前端，达到近似贪婪的效果$

### 与一致代价搜索对比
使用A\*搜索的总用时为0.5s
将启发式改为0，退化为一致代价搜索，360s没有返回结果
![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240505155220.png)

A\*搜索使用了曼哈顿距离的启发式信息，使得每一次的节点选择更倾向于起点到终点的直线上的节点，而更少拓展不在直线上的节点。
一致代价搜索更倾向于拓展代价小的节点，所以会拓展距离起点近的节点，拓展大量无用节点。特别是input10，由于地图过于大，导致常规时间无法求得答案