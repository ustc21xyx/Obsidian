## 论文标题及作者信息
**标题：** 状态网络功能的活性验证  
**作者：** Farnaz Yousefi, Johns Hopkins University; Anubhavnidhi Abhashkumar 和 Kausik Subramanian, University of Wisconsin-Madison; Kartik Hans, IIT Delhi; Soudeh Ghorbani, Johns Hopkins University; Aditya Akella, University of Wisconsin-Madison

## 摘要
网络验证工具几乎专注于各种安全属性，例如“可达性”不变量，例如，从主机$A$到主机$B$是否存在路径？因此，它们不适用于为越来越依赖状态网络功能的现代可编程网络提供强正确性保证。这类网络的正确操作依赖于更大的属性集，特别是活性属性。例如，一个只允许受邀外部流量的状态防火墙如果最终检测并阻止恶意连接，则工作正常，例如，如果它最终阻止外部主机$E$在收到来自$I$的请求之前尝试到达内部主机$I$。遗憾的是，验证活性属性在计算上昂贵，在某些情况下，甚至是不可判定的。现有的验证技术无法扩展以验证此类属性。在这项工作中，我们提供了一个组合编程抽象，使用紧凑的布尔公式对用此抽象表达的程序进行建模，并展示了这些公式上复杂属性的验证速度很快，例如，对于一个100主机网络，这些公式在验证UDP洪水缓解功能的关键属性时比简单基线快8倍。我们还提供了一个编译器，将使用我们的抽象编写的程序转换为P4程序。

## 1 引言
近年来，网络验证已成为检查网络是否满足重要属性的关键框架。虽然有多种工具在关注点上有所不同（例如，验证当前数据平面快照与验证网络的控制平面在故障下的情况），但它们都有一个共同的特点：主要关注验证各种风味的可达性不变量：网络中的一个点是否可以从另一个点到达？是否存在无环路径？路径是否拥堵？是否穿越了一个路标？在链接故障或外部消息下是否保持可达性？所有数据中心的最短路径是否可用于路由等。然而，这些工具忽略了一组更丰富的属性，这些属性取决于网络保证活性。
如今的网络越来越多地部署复杂且有状态的网络功能，例如入侵检测/防御系统（IDPS），它们监控流量以检测恶意活动和策略违规，并阻止此类活动。要依赖这样的网络，运营商需要验证“最终会发生一些好事（一个期望的属性）”。例如，考虑一个状态防火墙，其策略是，企业外部的主机$E$只有在内部主机$I$首先向$E$发送请求后，才允许向$I$发送流量。这里的活性属性是“是否最终会将应该被允许向$I$发送流量的主机$E$（即，$E$首先被$I$联系）列入白名单？”，或更准确地说，“$I$向$E$发送流量的事件导致防火墙将$E$列入白名单”。现有以可达性为中心的工具无法验证此属性：从$I$到$E$的路径的存在并不表明任何数据包实际上已经穿越了那条路径；同样，从$E$到$I$的可达性也不能保证它是在$I$发送流量之前还是之后建立的。

最近的工作表明，通过在等价类（ECs）上操作，可以有效地进行可达性验证，即，经历相同转发行为的数据包组。然而，验证活性不适用于此类技术，因为活性属性推理进展并涉及动态系统中事件的连续性。它们不能在系统的静态快照上进行验证。可以将动态网络（其中状态发生变化）建模为状态机，并且从概念上讲，现有的静态验证方法可以扩展以推理此机器的状态和转换的属性。然而，这种简单的方法会导致随着网络规模的增加而出现状态爆炸，因此在实践中是不切实际的。

在本文中，我们认为，使用自上而下的面向功能的策略来验证活性属性的目标是可实现的，这种策略重新思考了网络抽象，以提高验证效率。为了实现这一愿景：（a）我们为网络程序员提供了一个简单、熟悉的抽象，即一个大开关，以表达他们的意图。这种抽象强制逻辑上分离不同的网络功能。（b）然后我们将程序建模为一个紧凑的“无数据包”的数据结构，与常见的为数据包类建模转发行为的方法不同，它抽象掉了数据包的显式概念，而是专注于实现功能的实体：数据包处理规则。（c）我们构建并评估了我们系统的原型。

！！！！

## 3 功能验证

动态系统的活性属性验证的标准方法是将系统的行为建模为转换系统，并使用时序逻辑表达其期望的属性。这种方法的复杂性和可扩展性取决于状态机的大小。在本节中，我们展示如何将有状态的动态网络功能建模为紧凑的布尔“无数据包”转换系统，以便高效验证。在第4节中，我们将通过实验表明，与基于数据包的基线相比，这种方法显著减少了典型应用的平均验证时间。

### 3.1 网络作为转换系统

我们可以将网络建模为转换系统，这是一个分析框架，用于推理动态系统的行为，其中节点代表系统的状态（每个状态对应于系统变量的一个赋值），边代表状态转换。更正式地说，转换系统$TS$是一个元组$(S, Act, \rightarrow, I, AP, L)$：
- $S$是状态集，
- $Act$是动作集，
- $\rightarrow \subseteq S \times Act \times S$是转换关系，
- $I \subseteq S$是初始状态集，
- $AP$是原子命题集，
- $L: S \rightarrow 2^{AP}$是标签函数。

为方便起见，我们写$s \rightarrow^{\alpha} s'$代替$(s, \alpha, s')$。直观地说，转换系统从某个初始状态$s_0 \in I$开始，并根据转换关系$\rightarrow$演化。也就是说，如果$s$是当前状态，那么选择一个转换$s \rightarrow^{\alpha} s'$并采取它，即执行动作$\alpha$，系统从状态$s$演化到状态$s'$。在网络中，网络在每个点的状态是其转发状态（例如，规则和计数器），转换是改变状态的事件，例如，策略更新。

接下来，我们展示可以在这些转换系统上表达的属性，解释为什么验证活性很难，并演示如何将网络建模为紧凑的“无数据包”转换系统。

原子命题：原子命题是表达系统状态的简单已知事实的布尔值命题。我们将这些命题定义为$(h, a)$对，其中$h$和$a$分别是数据包的等价类和动作列表（例如，send(I)）。

对于网络转换系统$TS$，如果动作$a$适用于$h$中的所有数据包，则原子命题$(h, a)$在状态$s \in S$中成立。

标签函数：标签函数$L$将一组原子命题$L(s) \in 2^{AP}$关联到任何状态$s \in S$。也就是说，如果列表中的动作$a$适用于$h$中的所有数据包，则$(h, a)$存在于$L(s)$中。

属性：程序的执行可以显示为状态的无限序列：$s_0, s_1, \ldots$，其中每个状态$s_i$是在状态$s_{i-1}$中执行单个动作的结果。属性也定义为这样的序列集。如果程序定义的序列集包含在属性中，则属性在程序中成立。部分执行是程序状态的有限序列。

时序逻辑表达属性：时序逻辑是普通逻辑的扩展，通过添加关于时间的断言来表达属性。在这里，我们采用线性时序逻辑（LTL），它可以表达各种活性和安全属性。时序逻辑断言是使用普通逻辑运算$\wedge, \vee$和$\neg$以及一些时序运算符构建的——如果$P$和$S$是原子命题：(1) $GP$意味着“现在和将来”$P$成立，(2) $FP$意味着“现在或将来某个时候”$P$成立，(3) $P \rightarrow S$显示逻辑蕴含并意味着如果$P$现在为真，那么$S$将永远为真，(4) $P \cup S$意味着$P$保持真直到$S$变为真，(5) $\odot P$意味着$P$在“下一个”状态中成立。使用上述时序运算符，我们可以表达各种属性，例如，$F((src=E) \wedge dst=I), send(I)$断言最终$E$到$I$的数据包被交付，即$E$最终可以到达$I$。

### 3.2 活性与安全

在分布式系统中，属性的一个关键分类是安全和活性。这种分类很重要，因为这两组使用不同的技术进行证明。非正式地说，安全属性规定某些“坏事”（死锁，两个进程同时执行关键部分等）永远不会发生，而活性保证“某些好事”（终止，无饥饿自由，保证服务等）最终会发生。也就是说，对于属性$P$来说，如果$P$在执行中不成立，那么在某个点必须发生一些不可挽回的“坏事”。今天在网络中验证的大多数属性都是安全的：如果某个属性——如可达性不变量（$E$始终可以从$I$到达），路标（某一类流量始终穿越入侵检测系统），无拥塞和无环——被违反，那么就有一个可识别的点——比如网络的最新快照的变化——在那里“坏事”发生。部分执行$\gamma$对于属性$P$是活跃的，当且仅当存在状态序列$\beta$使得$P$在$\gamma\beta$中成立。对于所有部分执行都是活跃的属性是活性属性。与安全不同，对于活性属性，没有部分执行是不可挽回的——总是有可能在未来发生所需的“好事”。这使得检测活性违规变得具有挑战性，因为它从根本上需要对网络的整个状态空间进行穷尽搜索。在下一节中，我们将讨论通过使用紧凑的转换系统对网络进行建模来克服这一挑战的方法。

网络中的一些活性属性示例包括：(a)入侵检测系统最终检测到所有感染的主机，(b)所有主机最终变得可达，例如，在路由收敛后，(c)显示后门应用程序的可识别指纹导致主机被阻止。更一般地说，“事件$A$导致事件$B$”和“事件$B$最终发生”是两类活性属性，因为总是有可能发生“某些好事”（即事件$B$）。一个包含活性的属性的例子是完全正确性，它由部分正确性（程序永远不会生成错误的输出；一个安全属性）和终止（程序生成输出；一个活性属性）组成。

## 3.3 无数据包模型

模型检查的可行性与处理状态爆炸问题密切相关。为了缓解这个问题，我们尝试提供一个紧凑的“无数据包”结构，该结构仅模拟网络中执行功能的实体：数据包处理规则。此外，我们以最抽象的形式建模规则：作为布尔变量，抽象掉所有规则的属性，如它们的匹配字段、动作和优先级。这与普遍的网络验证技术形成对比，后者根据数据包和数据包的等价类（ECs）建模网络行为。布尔变量和公式提供了一种更紧凑的方式来表示转换系统的状态空间。最先进的模型检查器，如NuSMV，使用符号技术，如二进制决策图（BDDs），有效地探索具有布尔表示的转换系统。这种表示使模型检查器能够有效地探索极大的状态空间。接下来，我们将解释如何将动态网络功能的行为编码为无数据包模型。然后我们将在第4节中展示，这种无数据包建模方法在验证典型网络功能时显著减少了验证时间。

### 3.3.1 计数器的布尔公式

无数据包建模的第一个挑战是保留有状态程序的计数器语义。回想一下，在无数据包模型中，我们最初抽象掉了计数器。接下来，我们展示如何改进这些模型以纳入计数器的语义。

细化状态：为了建模计数器，我们观察到，如果一组网络状态中唯一变化的变量是计数器值，并且该计数器的值没有通过计数器条件，则所有这些状态中的转发行为保持不变。在监控功能中，对于0到$v_1$之间的所有计数器值，网络行为是相同的。这允许我们跟踪计数器谓词，即计数器的布尔值函数，而不是实际的计数器值。在监控功能中，我们可以定义以下三个谓词：$(0 \leq c_0<v_1), (v_1 \leq c_0<v_2)$和$(v_2 \leq c_0<m)$。在初始状态中，只有第一个谓词$(0 \leq c_0<v_1)$为真

转发行为不是由确切的计数器值决定的，而是由计数器通过阈值决定的，这使得计数器适合于谓词抽象，这是一种强大的技术，用于缓解具有大基类型（如整数）的程序验证的挑战。这种技术通过仅跟踪数据上的谓词并消除不可见的数据变量来减小模型的大小。

具体来说，计数器条件将区间划分为可能具有不同转发行为的子区间。让$R_i$是一个依赖于第$j$个计数器$c_j$的规则，即它处于活动状态，如果$c_j$的值在$(l_i, u_i)$范围内，并且$P_j=\operatorname{order}(\cup_{i}(l_i \cup u_i))$，即所有依赖于$c_j$的规则的所有下界和上界的非递减顺序列表。$P_{j,k}, l_{j,k}$和$u_{j,k}$分别表示计数器$c_j$的第$k$个子区间及其下界和上界。在监控程序中，$P_{0,0}=[0, v_1)$是第一个计数器的第一个子区间，$l_{0,0}=0$，$u_{0,0}=v_1$。当计数器值在此子区间中时，规则$R_0$可以处理数据包，因为其计数器条件$(l_0 \leq c_0<u_0)$得到满足，即$(l_0 \leq l_{0,0}) \wedge (u_{0,0} \leq u_0)$，其中$l_0=0$和$u_0=v_1$。另一方面，$R_2$不能处理数据包，因为其计数器条件在此子区间中不满足，即$(l_2 \leq \leq l_{0,0}) \wedge (u_{0,0} \not \leq u_2)$，其中$l_2=v_1$和$u_2=v_2$。

我们通过为每个规则$R_i$添加一个布尔变量$R_i'$来细化$TS$。我们的目标是在状态$s$中将此变量的值设置为true，如果$R_i$的计数器条件在$s$中得到满足，则为false。对于任何不依赖于计数器的规则$R_k$，$R_k'=$ true。$P_j$中的数字是唯一可以改变依赖于$c_j$的规则$R_i'$变量的地方。在监控程序中，$P_{0}=[0, v_1, v_2, m]$列出了$[0, m)$范围内唯一的点，其中依赖于计数器$c_{0}$的规则，例如$R_{0}$的条件可以从真变为假，反之亦然。

对于每个计数器$c_{j}$在无数据包模型中的状态，我们将状态划分为$|P_{j}|-1$个状态，其中$|P_{j}|$是$P_{j}$中点的数量，例如，在监控示例中，$P_{0}=4$。假设$R_i$是一个依赖于计数器$c_{j}$的规则，即$R_i$可以处理数据包，当计数器的值满足其计数器条件时：$l_i \leq c_{j}<u_i$。在每个细化状态中，$R_i'$的值应显示规则$R_i$的计数器条件是否在相应的子区间$P_{j,k}$中得到满足：$R_i'=(l_i \leq l_{j,k}) \wedge (u_{j,k} \leq u_i)$。

在任何给定的状态$s \in S$中，对于$P_{j,k}$的一个子区间，网络行为由那些(a)在该状态中处于活动状态的规则（即$R_i=$ true）和(b)不依赖于计数器或其计数器条件在该子区间中得到满足的规则决定（即$R_i'=$ true），例如，在监控示例的初始状态中，$R_{0}$和$R_{1}$是活动的（即$R_{0}=R_{1}=$ true）并且它们的计数器条件在第一个子区间$P_{0,0}=[0, v_1)$中得到满足（即$R_{0}'=R_{1}'=$ true）。


### 3.3.2 属性的布尔公式

我们之前解释了如何用数据包和期望动作来表达原子命题。属性是由原子命题构建的，在像之前工作中的基于数据包的转换系统中，如果原子命题$(h, a)$在状态$s$中成立，那么动作列表$a$适用于$h$中的所有数据包。无数据包建模的第二个挑战是在布尔无数据包模型上评估命题。在这部分，我们解释如何将$(h, a)$命题表达为利用已知规则优先级的规则上的布尔公式。

我们说一个规则$R_i$可以应用，如果(a) $R_i$是活动的，即$R_i=$ true，以及(b) $R_i$要么不依赖于任何计数器，要么其计数器条件得到满足，即$R_i'=$ true。为了执行一个规则，除了满足上述条件外，它应该是至少一个匹配数据包的最高优先级规则。

设$W_{0, n}=[R_0, R_1, \ldots, R_n]$和$W_{0, n}'=[R_0', R_1', \ldots, R_n']$分别是规则$R_i$和变量$R_i'$的列表，按规则优先级的非递增顺序排序，即如果$i<j$，则$R_i.\text{priority} \geq R_j.\text{priority}$，$R_i'.\text{priority} \geq R_j'.\text{priority}$。我们的目标是表达一个状态中是否成立命题的布尔公式。我们通过一个递归函数实现这一点：设$K((h, a), W_{0, n}, W_{0, n}')$是一个函数，如果$W_{0, n}$和$W_{0, n}'$满足命题$(h, a)$则为真，否则为假。对于两个特殊情况，其中(1) $h$为空和(2) $h$非空且规则列表为空，我们假设$K((h, a), W_{0, n}, W_{0, n}')$分别评估为真和假，因为任何条件对于不存在的数据包都成立(上述第1项，$h=\varnothing$)，而一组空的规则不满足数据包的任何条件(上述第2项，$h \neq \varnothing$且规则列表=[])。在其他条件下，我们有以下情况：

情况1：如果最高优先级规则$R_0$匹配$h$中的一些数据包，即如果$(h \cap R_0.\text{pkts}) \neq \varnothing$，其中$R_i.\text{pkts}$表示$R_i$匹配的数据包集合，并且其动作包括命题中的动作，即$a \subset R_0.\text{action}$，那么命题成立的条件是这两个条件之一成立：(a) 要么$R_0$可以应用($R_0 \wedge R_0'$)，并且对于所有不匹配$R_0$的$h$中的数据包，命题应该对下一个优先级较低的匹配规则成立，即$(R_0 \wedge R_0') \wedge K((h - R_0.\text{pkts}, a), W_{1, n}, W_{1, n}')$，或者(b) $R_0$不能应用($\neg(R_0 \wedge R_0')$，$R_0$要么没有在网络中安装，要么其计数器条件不满足)，但在这种情况下，对于$h$中的所有数据包，命题应该对下一个优先级较低的匹配规则成立，即$\neg(R_0 \wedge R_0') \wedge K((h, a), W_{1, n}, W_{1, n}')$。换句话说，$K((h, a), W_{0, n}, W_{0, n}') = (R_0 \wedge R_0') \wedge K((h - R_0.\text{pkts}, a), W_{1, n}, W_{1, n}') \vee \neg(R_0 \wedge R_0') \wedge K((h, a), W_{1, n}, W_{1, n}')$。

情况2：如果最高优先级规则$R_0$匹配$h$中的一些数据包，即如果$(h \cap R_0.\text{pkts}) \neq \varnothing$，并且其动作不包括命题中的动作，那么命题成立的条件是不可能应用$R_0$，即$\neg(R_0 \wedge R_0')$。否则，它匹配数据包但不应用预期的动作。此外，对于$h$中的所有数据包，命题应该对下一个优先级较低的匹配规则成立，即$K((h, a), W_{0, n}, W_{0, n}') = \neg(R_0 \wedge R_0') \wedge K((h, a), W_{1, n}, W_{1, n}')$。

情况3：如果最高优先级规则$R_0$不匹配$h$中的任何数据包，那么无论$R_0$是否可以应用，对于$h$中的所有数据包，命题应该对下一个优先级较低的匹配规则成立，即$K((h, a), W_{0, n}, W_{0, n}') = K((h, a), W_{1, n}, W_{1, n}')$。

通过递归地应用于网络中所有规则的有序列表(根据优先级)，$K((h, a), W_{0, n}, W_{0, n}')$将命题$(h, a)$表达为$R_i$和$R_i'$变量的布尔公式。例如，在图1中的IDPS功能中，命题$((\text{src}=I, \text{dst}=E), \text{send}())$被翻译为以下布尔公式：

$$\begin{aligned}
K(((\text{src=}I,\text{dst=}E),\text{send()}),W_{0,4},W_{0.4}^{\prime})& =  \\
(R_0\wedge R_0^{\prime})\wedge(K(((\text{src=}I,\text{dst=}E),\text{send()}),W_{1,4},W_{1,4}^{\prime}))& =  \\
\neg(R_0\wedge R_0^{\prime})\wedge K(((\text{src=}I,\text{dst=}E),\text{send()}),W_{2,4},W_{2,4}^{\prime})& =  \\
& =  \\
\neg(R_0\wedge R_0^{\prime})\wedge K(((\text{src=}I,\text{dst=}E),\text{send()}),W_{4,4},W_{4,4}^{\prime})& =  \\
\neg(R_0\wedge R_0^{\prime})\wedge  \\
(((R_4\wedge R_4^{\prime})\wedge K((\varnothing,\text{send()}),[]))\vee\\(\neg(R_4\wedge R_4^{\prime})\wedge K(((\text{src}=I,\text{dst}=E),\text{send()}),[])))&=\\\neg(R_0\wedge R_0^{\prime})\wedge(R_4\wedge R_4^{\prime}).&   \\
\end{aligned}$$

这个布尔公式是根据情况（2）、（3）、（3）、（3）、（1）以及前两个特殊情况指定的规则得出的。在图4中不同状态的真值不同，取决于那些状态中规则的真值，例如，在初始状态$S_0$中，$R_0=$ false且$R_4=$ true，意味着断言（$(\text{src}=I, \text{dst}=E)$, send()）成立（在这个状态中$I$可以与$E$通信），但在最终状态（$I$被阻止）中，$R_0=$ true且$R_4=$ true，此时为false。注意，在这个例子中$R_i'$变量始终为true，因为规则不依赖于计数器。

在网络转换系统$TS$中，标签函数$L$将每个状态映射到在该状态中成立的原子命题集合。也就是说，如果动作列表$a$适用于$h$中的所有数据包，则$(h, a)$存在于$L(s)$中，即$K((h, a), W_{0, n}, W_{0, n}')=$ true，其中$W_{0, n}$和$W_{0, n}'$分别是$s$中规则$R_i$和变量$R_i'$的列表（按规则优先级的非递增顺序排序）。

### 4 实施和评估

为了评估我们设计的性能，我们构建了一个原型，使网络运营商能够编程和验证他们的功能，并且开发了一个编译器，将这些功能转换为可在可编程交换ASIC上执行的程序。在简要概述我们的原型之后，我们将展示我们的网络抽象和规范语言是如何表达的，并且只引入了最小的开销。我们还将展示与基于数据包的基线相比，无数据包模型验证不同属性的速度更快、更具可扩展性，例如，对于一个有100个主机的网络，无数据包模型在验证UDP洪水缓解功能的生存性属性时，比基于数据包的模型快8倍。

#### 4.1 实施

接口：我们的系统提供了两个接口：一个是允许网络运营商在我们的抽象上编程其功能的一大开关接口（§2），另一个是允许他们表达所需属性的规范接口（§3）。然后我们的生成器自动构建无数据包模型和表示规范的布尔公式，如（§3）中所解释的，并与NuSMV这一最先进的模型检查器交互，以验证规范属性。

将抽象编译为P4程序：P4是一种用于表达可编程数据平面的数据包处理的语言。与可编程数据平面一起，控制平面负责填充P4程序定义的表。我们构建了一个编译器，将使用我们抽象编写的一大开关程序编译为P4_16程序，用于P4行为模型，这是一个开源的可编程软件交换机。与软件交换机一起，我们开发了一个控制平面，它添加和删除表规则。我们描述了编译的一些显著特点：

(a) 功能分解：我们将抽象中的每个表映射到一个P4表，其匹配字段和动作是使用表中的规则构建的。网络功能遍历策略使用P4控制流构造实现，例如，有条件地遍历防火墙表fw：
```
if (meta.visit_fw == 1) {
    fw.apply();
}
```
其中meta.visit_fw是由防火墙表之前的表使用的元数据变量，以确保数据包通过防火墙表。

(b) 可操作的测量：我们使用P4的寄存器来支持增加和匹配跨多个规则共享的计数器。如果抽象中的表使用计数器，我们创建一个单独的P4表，负责更新共享计数器并将计数器状态转移到元数据，以便功能表可以使用该值进行匹配。这有助于我们将寄存器访问限制在单个表中。因此，数据包处理可以以线速进行。

(c) 添加/删除动作：当前，P4数据平面不支持添加/删除动作，即添加或删除其他表规则的规则动作，这是由于现有平台的硬件限制。我们通过克隆数据包到控制平面来支持此功能，类似于OpenFlow中的PacketIn功能。当程序中的规则具有添加/删除动作时，我们的交换程序在数据平面克隆数据包并将其发送到本地交换机控制平面；控制平面（我们也生成的）然后根据程序中的添加/删除动作添加/删除表规则。这种方法的开销是将一些数据包（特别是在连接中匹配特定规则的第一个数据包）转发到本地交换机CPU——这是我们为了缺乏数据平面对添加/删除动作的支持而支付的代价。

#### 4.2 评估

表达性：尽管我们的一大开关抽象很简单，但它使开发者能够表达广泛的应用程序和网络功能。表1显示了我们在框架中开发的功能列表。这些程序的完整描述在（§8）中提供。网络策略可以在我们的一大开关抽象上仅用几行代码简洁地表达（表1中的第3列），例如，一个简单的有状态防火墙策略，只允许由给定部门的主机发起连接的流量，可以在一大开关抽象上用3行代码表达。同一策略的编译P4代码用133行代码表达（包括100行用于头和解析器的样板代码）和50行代码用于P4控制平面，用于在数据平面克隆数据包并从控制平面添加规则。各种规范属性，包括实践中最常见的规范模式，也可以在（§3）中介绍的时态逻辑中指定。

有限的开销：我们的抽象中的添加/删除动作目前在交换ASIC中不直接支持。我们的P4编译器通过在规则具有此类动作时涉及控制器来实现这些动作。为了测量涉及控制器的开销，我们部署了表1中列出的功能，并回放了一个大学数据中心的数据包跟踪，包含超过102K个数据包和1791个IP地址，并测量了调用控制器的频率。对于所有功能来说，这种开销都是适度的，即0-0.3％（表1中的第4列）。

验证时间：我们测试了有界时间验证无数据包和基于数据包模型的可扩展性，以回答诸如哪些功能和属性可以使用每种方法验证、验证时间如何随网络（因此模型）大小扩展、以及它如何随属性大小扩展等问题。为此，对于表1中具有每个主机策略的功能（例如，重点用户检测器、端口敲击、速率限制器、网络钓鱼/垃圾邮件检测器和UDP洪水缓解功能），我们为网络中的每个主机定义一个策略。例如，重点用户检测器部署了一个每个新SYN数据包都会增加的每源IP计数器，并在计数器超过阈值时开始丢弃数据包（表4）。对于在通信主机对或流上定义策略的功能，例如FTP监控和DNS放大缓解功能，我们运行上述相同的数据中心跟踪以找到通信主机对和匹配流，并为每个定义一个策略。对于将主机分类为集合的功能，例如具有内部和外部主机集的防火墙功能，我们随机将每个主机分配到一个集合中。最后，对于计数器界限，我们从可能值集合上的均匀分布中抽取随机样本。

我们测量了各种功能、属性和网络规模的验证时间，对于无数据包和基于数据包的模型。请注意，以这种方式增加网络大小会导致更大的模型。对于每个实验，我们进行了20次重复试验，每次试验的时间预算为1000秒，即当验证时间超过1000秒时，我们停止验证过程。在展示我们的结果之前，我们将简要概述我们的基于数据包的基线。

基于数据包的转换系统作为基线：扩展静态验证的一种强大技术是将网络切分为一组数据包的等价类（ECs）。每个EC是一组始终在网络中经历相同转发动作的数据包。如先前的工作所示，这种方法可以扩展到模型动态网络。为此，可以使用将数据包分类为ECs的验证器来检测程序的ECs。




