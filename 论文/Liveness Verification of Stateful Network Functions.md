## 论文标题及作者信息
**标题：** 状态网络功能的活性验证  
**作者：** Farnaz Yousefi, Johns Hopkins University; Anubhavnidhi Abhashkumar 和 Kausik Subramanian, University of Wisconsin-Madison; Kartik Hans, IIT Delhi; Soudeh Ghorbani, Johns Hopkins University; Aditya Akella, University of Wisconsin-Madison

## 摘要
网络验证工具几乎专注于各种安全属性，例如“可达性”不变量，例如，从主机$A$到主机$B$是否存在路径？因此，它们不适用于为越来越依赖状态网络功能的现代可编程网络提供强正确性保证。这类网络的正确操作依赖于更大的属性集，特别是活性属性。例如，一个只允许受邀外部流量的状态防火墙如果最终检测并阻止恶意连接，则工作正常，例如，如果它最终阻止外部主机$E$在收到来自$I$的请求之前尝试到达内部主机$I$。遗憾的是，验证活性属性在计算上昂贵，在某些情况下，甚至是不可判定的。现有的验证技术无法扩展以验证此类属性。在这项工作中，我们提供了一个组合编程抽象，使用紧凑的布尔公式对用此抽象表达的程序进行建模，并展示了这些公式上复杂属性的验证速度很快，例如，对于一个100主机网络，这些公式在验证UDP洪水缓解功能的关键属性时比简单基线快8倍。我们还提供了一个编译器，将使用我们的抽象编写的程序转换为P4程序。

## 1 引言
近年来，网络验证已成为检查网络是否满足重要属性的关键框架。虽然有多种工具在关注点上有所不同（例如，验证当前数据平面快照与验证网络的控制平面在故障下的情况），但它们都有一个共同的特点：主要关注验证各种风味的可达性不变量：网络中的一个点是否可以从另一个点到达？是否存在无环路径？路径是否拥堵？是否穿越了一个路标？在链接故障或外部消息下是否保持可达性？所有数据中心的最短路径是否可用于路由等。然而，这些工具忽略了一组更丰富的属性，这些属性取决于网络保证活性。
如今的网络越来越多地部署复杂且有状态的网络功能，例如入侵检测/防御系统（IDPS），它们监控流量以检测恶意活动和策略违规，并阻止此类活动。要依赖这样的网络，运营商需要验证“最终会发生一些好事（一个期望的属性）”。例如，考虑一个状态防火墙，其策略是，企业外部的主机$E$只有在内部主机$I$首先向$E$发送请求后，才允许向$I$发送流量。这里的活性属性是“是否最终会将应该被允许向$I$发送流量的主机$E$（即，$E$首先被$I$联系）列入白名单？”，或更准确地说，“$I$向$E$发送流量的事件导致防火墙将$E$列入白名单”。现有以可达性为中心的工具无法验证此属性：从$I$到$E$的路径的存在并不表明任何数据包实际上已经穿越了那条路径；同样，从$E$到$I$的可达性也不能保证它是在$I$发送流量之前还是之后建立的。

最近的工作表明，通过在等价类（ECs）上操作，可以有效地进行可达性验证，即，经历相同转发行为的数据包组。然而，验证活性不适用于此类技术，因为活性属性推理进展并涉及动态系统中事件的连续性。它们不能在系统的静态快照上进行验证。可以将动态网络（其中状态发生变化）建模为状态机，并且从概念上讲，现有的静态验证方法可以扩展以推理此机器的状态和转换的属性。然而，这种简单的方法会导致随着网络规模的增加而出现状态爆炸，因此在实践中是不切实际的。

在本文中，我们认为，使用自上而下的面向功能的策略来验证活性属性的目标是可实现的，这种策略重新思考了网络抽象，以提高验证效率。为了实现这一愿景：（a）我们为网络程序员提供了一个简单、熟悉的抽象，即一个大开关，以表达他们的意图。这种抽象强制逻辑上分离不同的网络功能。（b）然后我们将程序建模为一个紧凑的“无数据包”的数据结构，与常见的为数据包类建模转发行为的方法不同，它抽象掉了数据包的显式概念，而是专注于实现功能的实体：数据包处理规则。（c）我们构建并评估了我们系统的原型。

## 3 功能验证

动态系统的活性属性验证的标准方法是将系统的行为建模为转换系统，并使用时序逻辑表达其期望的属性。这种方法的复杂性和可扩展性取决于状态机的大小。在本节中，我们展示如何将有状态的动态网络功能建模为紧凑的布尔“无数据包”转换系统，以便高效验证。在第4节中，我们将通过实验表明，与基于数据包的基线相比，这种方法显著减少了典型应用的平均验证时间。

### 3.1 网络作为转换系统

我们可以将网络建模为转换系统，这是一个分析框架，用于推理动态系统的行为，其中节点代表系统的状态（每个状态对应于系统变量的一个赋值），边代表状态转换。更正式地说，转换系统$TS$是一个元组$(S, Act, \rightarrow, I, AP, L)$：
- $S$是状态集，
- $Act$是动作集，
- $\rightarrow \subseteq S \times Act \times S$是转换关系，
- $I \subseteq S$是初始状态集，
- $AP$是原子命题集，
- $L: S \rightarrow 2^{AP}$是标签函数。

为方便起见，我们写$s \rightarrow^{\alpha} s'$代替$(s, \alpha, s')$。直观地说，转换系统从某个初始状态$s_0 \in I$开始，并根据转换关系$\rightarrow$演化。也就是说，如果$s$是当前状态，那么选择一个转换$s \rightarrow^{\alpha} s'$并采取它，即执行动作$\alpha$，系统从状态$s$演化到状态$s'$。在网络中，网络在每个点的状态是其转发状态（例如，规则和计数器），转换是改变状态的事件，例如，策略更新。

接下来，我们展示可以在这些转换系统上表达的属性，解释为什么验证活性很难，并演示如何将网络建模为紧凑的“无数据包”转换系统。

原子命题：原子命题是表达系统状态的简单已知事实的布尔值命题。我们将这些命题定义为$(h, a)$对，其中$h$和$a$分别是数据包的等价类和动作列表（例如，send(I)）。

对于网络转换系统$TS$，如果动作$a$适用于$h$中的所有数据包，则原子命题$(h, a)$在状态$s \in S$中成立。

标签函数：标签函数$L$将一组原子命题$L(s) \in 2^{AP}$关联到任何状态$s \in S$。也就是说，如果列表中的动作$a$适用于$h$中的所有数据包，则$(h, a)$存在于$L(s)$中。

属性：程序的执行可以显示为状态的无限序列：$s_0, s_1, \ldots$，其中每个状态$s_i$是在状态$s_{i-1}$中执行单个动作的结果。属性也定义为这样的序列集。如果程序定义的序列集包含在属性中，则属性在程序中成立。部分执行是程序状态的有限序列。

时序逻辑表达属性：时序逻辑是普通逻辑的扩展，通过添加关于时间的断言来表达属性。在这里，我们采用线性时序逻辑（LTL），它可以表达各种活性和安全属性。时序逻辑断言是使用普通逻辑运算$\wedge, \vee$和$\neg$以及一些时序运算符构建的——如果$P$和$S$是原子命题：(1) $GP$意味着“现在和将来”$P$成立，(2) $FP$意味着“现在或将来某个时候”$P$成立，(3) $P \rightarrow S$显示逻辑蕴含并意味着如果$P$现在为真，那么$S$将永远为真，(4) $P \cup S$意味着$P$保持真直到$S$变为真，(5) $\odot P$意味着$P$在“下一个”状态中成立。使用上述时序运算符，我们可以表达各种属性，例如，$F((src=E) \wedge dst=I), send(I)$断言最终$E$到$I$的数据包被交付，即$E$最终可以到达$I$。

### 3.2 活性与安全

在分布式系统中，属性的一个关键分类是安全和活性。这种分类很重要，因为这两组使用不同的技术进行证明。非正式地说，安全属性规定某些“坏事”（死锁，两个进程同时执行关键部分等）永远不会发生，而活性保证“某些好事”（终止，无饥饿自由，保证服务等）最终会发生。也就是说，对于属性$P$来说，如果$P$在执行中不成立，那么在某个点必须发生一些不可挽回的“坏事”。今天在网络中验证的大多数属性都是安全的：如果某个属性——如可达性不变量（$E$始终可以从$I$到达），路标（某一类流量始终穿越入侵检测系统），无拥塞和无环——被违反，那么就有一个可识别的点——比如网络的最新快照的变化——在那里“坏事”发生。部分执行$\gamma$对于属性$P$是活跃的，当且仅当存在状态序列$\beta$使得$P$在$\gamma\beta$中成立。对于所有部分执行都是活跃的属性是活性属性。与安全不同，对于活性属性，没有部分执行是不可挽回的——总是有可能在未来发生所需的“好事”。这使得检测活性违规变得具有挑战性，因为它从根本上需要对网络的整个状态空间进行穷尽搜索。在下一节中，我们将讨论通过使用紧凑的转换系统对网络进行建模来克服这一挑战的方法。

网络中的一些活性属性示例包括：(a)入侵检测系统最终检测到所有感染的主机，(b)所有主机最终变得可达，例如，在路由收敛后，(c)显示后门应用程序的可识别指纹导致主机被阻止。更一般地说，“事件$A$导致事件$B$”和“事件$B$最终发生”是两类活性属性，因为总是有可能发生“某些好事”（即事件$B$）。一个包含活性的属性的例子是完全正确性，它由部分正确性（程序永远不会生成错误的输出；一个安全属性）和终止（程序生成输出；一个活性属性）组成。

## 3.3 无数据包模型

模型检查的可行性与处理状态爆炸问题密切相关。为了缓解这个问题，我们尝试提供一个紧凑的“无数据包”结构，该结构仅模拟网络中执行功能的实体：数据包处理规则。此外，我们以最抽象的形式建模规则：作为布尔变量，抽象掉所有规则的属性，如它们的匹配字段、动作和优先级。这与普遍的网络验证技术形成对比，后者根据数据包和数据包的等价类（ECs）建模网络行为。布尔变量和公式提供了一种更紧凑的方式来表示转换系统的状态空间。最先进的模型检查器，如NuSMV，使用符号技术，如二进制决策图（BDDs），有效地探索具有布尔表示的转换系统。这种表示使模型检查器能够有效地探索极大的状态空间。接下来，我们将解释如何将动态网络功能的行为编码为无数据包模型。然后我们将在第4节中展示，这种无数据包建模方法在验证典型网络功能时显著减少了验证时间。

### 3.3.1 计数器的布尔公式

无数据包建模的第一个挑战是保留有状态程序的计数器语义。回想一下，在无数据包模型中，我们最初抽象掉了计数器。接下来，我们展示如何改进这些模型以纳入计数器的语义。

细化状态：为了建模计数器，我们观察到，如果一组网络状态中唯一变化的变量是计数器值，并且该计数器的值没有通过计数器条件，则所有这些状态中的转发行为保持不变。在监控功能中，对于0到$v_1$之间的所有计数器值，网络行为是相同的。这允许我们跟踪计数器谓词，即计数器的布尔值函数，而不是实际的计数器值。在监控功能中，我们可以定义以下三个谓词：$(0 \leq c_0<v_1), (v_1 \leq c_0<v_2)$和$(v_2 \leq c_0<m)$。在初始状态中，只有第一个谓词$(0 \leq c_0<v_1)$为真

转发行为不是由确切的计数器值决定的，而是由计数器通过阈值决定的，这使得计数器适合于谓词抽象，这是一种强大的技术，用于缓解具有大基类型（如整数）的程序验证的挑战。这种技术通过仅跟踪数据上的谓词并消除不可见的数据变量来减小模型的大小。

具体来说，计数器条件将区间划分为可能具有不同转发行为的子区间。让$R_i$是一个依赖于第$j$个计数器$c_j$的规则，即它处于活动状态，如果$c_j$的值在$(l_i, u_i)$范围内，并且$P_j=\operatorname{order}(\cup_{i}(l_i \cup u_i))$，即所有依赖于$c_j$的规则的所有下界和上界的非递减顺序列表。$P_{j,k}, l_{j,k}$和$u_{j,k}$分别表示计数器$c_j$的第$k$个子区间及其下界和上界。在监控程序中，$P_{0,0}=[0, v_1)$是第一个计数器的第一个子区间，$l_{0,0}=0$，$u_{0,0}=v_1$。当计数器值在此子区间中时，规则$R_0$可以处理数据包，因为其计数器条件$(l_0 \leq c_0<u_0)$得到满足，即$(l_0 \leq l_{0,0}) \wedge (u_{0,0} \leq u_0)$，其中$l_0=0$和$u_0=v_1$。另一方面，$R_2$不能处理数据包，因为其计数器条件在此子区间中不满足，即$(l_2 \leq \leq l_{0,0}) \wedge (u_{0,0} \not \leq u_2)$，其中$l_2=v_1$和$u_2=v_2$。

我们通过为每个规则$R_i$添加一个布尔变量$R_i'$来细化$TS$。我们的目标是在状态$s$中将此变量的值设置为true，如果$R_i$的计数器条件在$s$中得到满足，则为false。对于任何不依赖于计数器的规则$R_k$，$R_k'=$ true。$P_j$中的数字是唯一可以改变依赖于$c_j$的规则$R_i'$变量的地方。在监控程序中，$P_{0}=[0, v_1, v_2, m]$列出了$[0, m)$范围内唯一的点，其中依赖于计数器$c_{0}$的规则，例如$R_{0}$的条件可以从真变为假，反之亦然。

对于每个计数器$c_{j}$在无数据包模型中的状态，我们将状态划分为$|P_{j}|-1$个状态，其中$|P_{j}|$是$P_{j}$中点的数量，例如，在监控示例中，$P_{0}=4$。假设$R_i$是一个依赖于计数器$c_{j}$的规则，即$R_i$可以处理数据包，当计数器的值满足其计数器条件时：$l_i \leq c_{j}<u_i$。在每个细化状态中，$R_i'$的值应显示规则$R_i$的计数器条件是否在相应的子区间$P_{j,k}$中得到满足：$R_i'=(l_i \leq l_{j,k}) \wedge (u_{j,k} \leq u_i)$。

在任何给定的状态$s \in S$中，对于$P_{j,k}$的一个子区间，网络行为由那些(a)在该状态中处于活动状态的规则（即$R_i=$ true）和(b)不依赖于计数器或其计数器条件在该子区间中得到满足的规则决定（即$R_i'=$ true），例如，在监控示例的初始状态中，$R_{0}$和$R_{1}$是活动的（即$R_{0}=R_{1}=$ true）并且它们的计数器条件在第一个子区间$P_{0,0}=[0, v_1)$中得到满足（即$R_{0}'=R_{1}'=$ true）。


### 3.3.2 属性的布尔公式

我们之前解释了如何用数据包和期望动作来表达原子命题。属性是由原子命题构建的，在像之前工作中的基于数据包的转换系统中，如果原子命题$(h, a)$在状态$s$中成立，那么动作列表$a$适用于$h$中的所有数据包。无数据包建模的第二个挑战是在布尔无数据包模型上评估命题。在这部分，我们解释如何将$(h, a)$命题表达为利用已知规则优先级的规则上的布尔公式。

我们说一个规则$R_i$可以应用，如果(a) $R_i$是活动的，即$R_i=$ true，以及(b) $R_i$要么不依赖于任何计数器，要么其计数器条件得到满足，即$R_i'=$ true。为了执行一个规则，除了满足上述条件外，它应该是至少一个匹配数据包的最高优先级规则。

设$W_{0, n}=[R_0, R_1, \ldots, R_n]$和$W_{0, n}'=[R_0', R_1', \ldots, R_n']$分别是规则$R_i$和变量$R_i'$的列表，按规则优先级的非递增顺序排序，即如果$i<j$，则$R_i.\text{priority} \geq R_j.\text{priority}$，$R_i'.\text{priority} \geq R_j'.\text{priority}$。我们的目标是表达一个状态中是否成立命题的布尔公式。我们通过一个递归函数实现这一点：设$K((h, a), W_{0, n}, W_{0, n}')$是一个函数，如果$W_{0, n}$和$W_{0, n}'$满足命题$(h, a)$则为真，否则为假。对于两个特殊情况，其中(1) $h$为空和(2) $h$非空且规则列表为空，我们假设$K((h, a), W_{0, n}, W_{0, n}')$分别评估为真和假，因为任何条件对于不存在的数据包都成立(上述第1项，$h=\varnothing$)，而一组空的规则不满足数据包的任何条件(上述第2项，$h \neq \varnothing$且规则列表=[])。在其他条件下，我们有以下情况：

情况1：如果最高优先级规则$R_0$匹配$h$中的一些数据包，即如果$(h \cap R_0.\text{pkts}) \neq \varnothing$，其中$R_i.\text{pkts}$表示$R_i$匹配的数据包集合，并且其动作包括命题中的动作，即$a \subset R_0.\text{action}$，那么命题成立的条件是这两个条件之一成立：(a) 要么$R_0$可以应用($R_0 \wedge R_0'$)，并且对于所有不匹配$R_0$的$h$中的数据包，命题应该对下一个优先级较低的匹配规则成立，即$(R_0 \wedge R_0') \wedge K((h - R_0.\text{pkts}, a), W_{1, n}, W_{1, n}')$，或者(b) $R_0$不能应用($\neg(R_0 \wedge R_0')$，$R_0$要么没有在网络中安装，要么其计数器条件不满足)，但在这种情况下，对于$h$中的所有数据包，命题应该对下一个优先级较低的匹配规则成立，即$\neg(R_0 \wedge R_0') \wedge K((h, a), W_{1, n}, W_{1, n}')$。换句话说，$K((h, a), W_{0, n}, W_{0, n}') = (R_0 \wedge R_0') \wedge K((h - R_0.\text{pkts}, a), W_{1, n}, W_{1, n}') \vee \neg(R_0 \wedge R_0') \wedge K((h, a), W_{1, n}, W_{1, n}')$。

情况2：如果最高优先级规则$R_0$匹配$h$中的一些数据包，即如果$(h \cap R_0.\text{pkts}) \neq \varnothing$，并且其动作不包括命题中的动作，那么命题成立的条件是不可能应用$R_0$，即$\neg(R_0 \wedge R_0')$。否则，它匹配数据包但不应用预期的动作。此外，对于$h$中的所有数据包，命题应该对下一个优先级较低的匹配规则成立，即$K((h, a), W_{0, n}, W_{0, n}') = \neg(R_0 \wedge R_0') \wedge K((h, a), W_{1, n}, W_{1, n}')$。

情况3：如果最高优先级规则$R_0$不匹配$h$中的任何数据包，那么无论$R_0$是否可以应用，对于$h$中的所有数据包，命题应该对下一个优先级较低的匹配规则成立，即$K((h, a), W_{0, n}, W_{0, n}') = K((h, a), W_{1, n}, W_{1, n}')$。

通过递归地应用于网络中所有规则的有序列表(根据优先级)，$K((h, a), W_{0, n}, W_{0, n}')$将命题$(h, a)$表达为$R_i$和$R_i'$变量的布尔公式。例如，在图1中的IDPS功能中，命题$((\text{src}=I, \text{dst}=E), \text{send}())$被翻译为以下布尔公式：

$$\begin{aligned}
K(((\text{src=}I,\text{dst=}E),\text{send()}),W_{0,4},W_{0.4}^{\prime})& =  \\
(R_0\wedge R_0^{\prime})\wedge(K(((\text{src=}I,\text{dst=}E),\text{send()}),W_{1,4},W_{1,4}^{\prime}))& =  \\
\neg(R_0\wedge R_0^{\prime})\wedge K(((\text{src=}I,\text{dst=}E),\text{send()}),W_{2,4},W_{2,4}^{\prime})& =  \\
& =  \\
\neg(R_0\wedge R_0^{\prime})\wedge K(((\text{src=}I,\text{dst=}E),\text{send()}),W_{4,4},W_{4,4}^{\prime})& =  \\
\neg(R_0\wedge R_0^{\prime})\wedge  \\
(((R_4\wedge R_4^{\prime})\wedge K((\varnothing,\text{send()}),[]))\vee\\(\neg(R_4\wedge R_4^{\prime})\wedge K(((\text{src}=I,\text{dst}=E),\text{send()}),[])))&=\\\neg(R_0\wedge R_0^{\prime})\wedge(R_4\wedge R_4^{\prime}).&   \\
\end{aligned}$$

这个布尔公式是根据情况（2）、（3）、（3）、（3）、（1）以及前两个特殊情况指定的规则得出的。在图4中不同状态的真值不同，取决于那些状态中规则的真值，例如，在初始状态$S_0$中，$R_0=$ false且$R_4=$ true，意味着断言（$(\text{src}=I, \text{dst}=E)$, send()）成立（在这个状态中$I$可以与$E$通信），但在最终状态（$I$被阻止）中，$R_0=$ true且$R_4=$ true，此时为false。注意，在这个例子中$R_i'$变量始终为true，因为规则不依赖于计数器。

在网络转换系统$TS$中，标签函数$L$将每个状态映射到在该状态中成立的原子命题集合。也就是说，如果动作列表$a$适用于$h$中的所有数据包，则$(h, a)$存在于$L(s)$中，即$K((h, a), W_{0, n}, W_{0, n}')=$ true，其中$W_{0, n}$和$W_{0, n}'$分别是$s$中规则$R_i$和变量$R_i'$的列表（按规则优先级的非递增顺序排序）。




