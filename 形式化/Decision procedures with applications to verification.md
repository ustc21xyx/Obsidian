
# 命题逻辑的决策程序


## CDCL 算法
### 2.2.5 Decision Heuristics 决策启发式

SAT 求解中最重要的因素可能就是选择变量和变量值的策略。这种策略被称为 SAT 求解器的==决策启发式==。
下面介绍一些重要的决策启发式：

#### Jeroslow-Wang
$给定一个CNF公式\mathcal{B}，对于每个\mathcal{l}计算$
$$\begin{aligned}J(l)&=\Sigma_{\omega\in\mathcal{B},l\in\omega}2^{-|\omega|},\end{aligned}$$
$其中\omega 代表一个子句，|\omega|是它的长度，选择使得|mathcal{J}(\mathcal{l})最大的\mathcal{l}，并且\mathcal{l}和\neg \mathcal{l}都没有被断言$
这个启发式会给频繁出现在短子句的字面量(literals)更高的优先级。它可以是静态的，也可以是动态的。动态的只考虑未被满足的子句。动态的启发式拥有更好的决策，但每次的决策也会有更大的开销。

#### Dynamic Largest Individual Sum(DLIS)
在每一个决策层，在所有未被赋值的字面量中，选择可以满足最多数量的未被满足的子句的字面量。
想要实现这样的一个启发式，最常见的做法是：对于每个字面量，维护一个指针，指向一个维护所有它出现的子句的列表（类似倒排索引）。
这个策略有巨大的开销，因为单次决策的复杂度与子句数量呈线性关系。
这个策略的另一个变体是：计算由这次决策，通过BCP可以满足的子句数量。这个策略拥有更好的决策，但也拥有更大的开销。

#### Variable State Independent Decaying Sum(VSIDS) and Variants
这是 SAT 求解器 Chaff \[202\] 中引入的一种策略，它让人想起 DLIS，但效率要高得多。首先，在计算每个字面出现的子句数量时，忽略该子句是否已经满足的问题。这意味着对每次决策质量的估算都会受到影响，但决策的复杂性会更好：假设我们将字面意思按分数排序保存在一个列表中，那么决策所需的时间是不变的。其次，定期将所有分数除以2。
这个策略的目的是使得决策启发式是**冲突驱动(Conflict-driven)**,这意味着它要优先解决最新被发现的冲突。为了达到这个目标，我们需要给予那些出现在最新冲突的变量更高的分数。
回想一下，每次冲突都会产生一个冲突子句。一个新的冲突子句和其他子句一样，会给其中出现的每个字面的分值加 1。自添加该冲突子句以来，时间过得越久，这些字面的得分被除以 2 的次数就越多。引入了 VSIDS 的 SAT 求解器 Chaff 可以通过控制分数被除的频率和除以分数的常数来调整这一策略。事实证明，不同的 CNF 公式族使用不同的参数求解效果最佳。

还有其他冲突驱动的启发式。例如，MiniSAT采用的策略。
MiniSAT为每一个变量维护一个活动分值，用来衡量每个变量在推断新子句时的参与程度。如果一个子句c是由子句$c_1,...,c_n$推断出来的，那么子句$c_1,...,c_n$中的每一个v的实例a，都会使得v增加一个inc。inc的大小在每一次冲突后都会乘以1.05，因此罪域最近冲突的变量得分最高。
为了防止溢出，如果某个变量的活动得分超过$10^{100}$，则将所有变量的得分以及inc乘以$10^{-100}$。得分最高的变量被选中，为该变量选择的值要么是假值，要么是随机值，要么是该变量之前的赋值。

在MiniSAT冲突驱动的求解器中，并没有试图猜测变量的正确值（即它是为每个变量维护活动分数，而不是针对字面维护分数），这一事实表明，重要的是搜索的局部性和学习，而不是对分支的正确猜测。这并不奇怪：即使在可满足公式中，大多数的分支也不会导致满足赋值

#### Clause-Based Heuristics
在这一类启发式中，在最近冲突子句中出现的字面量会被赋予绝对优先级。
针对每一个变量，使用类似VSIDS的方式维护一个分数（出现加一，定期除以2）。再针对每一个字面量，也维护一个分数，但**不**定期除以2。
将所有的冲突子句放入一个栈中。每当一个决策完成时，找到栈中未被解决的子句中最靠近栈顶的。从这个子句中选择分数最高的变量，赋予分数更高的字面量对应的值。当栈为空时，策略不变，改为从所有未被赋值的变量选择分值最高的变量。
这种启发式最早是在一个名为 Berkmin 的 SAT 求解器中实现的。其原理是给予最近冲突中出现的变量绝对优先权，根据经验，这似乎更有效。与 VSIDS 不同的是，它只关注未解决的冲突。
一种不同的基于子句的策略称为Clause-Move-To-Front（CMTF）。它与Berkmin相似，不同之处在于，在学习新子句时，参与解决新子句的k个子句（k是一个可调常数）被推到列表的末尾，紧接在新子句之前。这一策略的理由是它保持了搜索的集中性。例如，假设一个子句c是从c1、c2和c3中解析出来的。我们可以写作$c1 ∧ c2 ∧ c3 ⇒ c$，这表明满足c比满足$c1 ∧ c2 ∧ c3$更容易。因此，当当前部分赋值导致$c1 ∧ c2 ∧ c3$矛盾时，求解器回溯，并在返回这些子句之前尝试满足一个更容易的公式，即c。CMTF在称为HaifaSat的SAT求解器中实现，另一种称为Clause-Based Heuristic（CBH）的变体在Eureka中实现

### 2.2.6 Resolution图和不可满足核心

**Definition 2.13 二元解析图(binary resolution graph)**：二元解析图是一个有向无环图，其中每个节点都标有一个子句，每个根节点都对应一个原始子句，每个非根节点都有恰好两条进入边，并对应一个通过二元解析从其父节点在图中派生出来的子句。

**Deﬁnition 2.14 超解析图(hyper-resolution graph)：** 超解析图是一个有向无环图，其中每个节点都标有一个子句，每个根节点都对应一个原始子句，每个非根节点都有两条或两条以上的输入边，并对应一个通过二进制解析从图中其父节点派生出来的子句，也可能是通过图中未表示的其他子句派生出来的子句。
![image.png](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240515181335.png)
在不可满足公式的情况下，解析图有一个汇节点（即只有输入边的节点），它对应于一个空子句。

解析图可以帮助我们推导一个不可满足公式的不可满足核心
**Definition 2.16 不可满足核心(unsatisfiable core)**：一个不可满足的CNF公式的**不可满足核心**：该CNF初始子句集合中的任意不可满足的子句子集。
一个CNF的不可满足核心，在我们研究问题时可能很有用，因为它可以满足我们集中关注不可满足的原因。

解析图的另一个常见用途是证明 SAT 求解器得出的公式不可满足的结论。与可满足实例的情况不同，可满足赋值是一个易于检查的证据，而检查不可满足结果则比较困难。然而，利用解析图，独立检查程序可以从原始子句开始重放解析步骤，直到得出空子句为止。这种验证所需的时间与解析证明的大小成线性关系。

### 2.2.7 递增满意度
在许多工业应用中，SAT 求解器都是更大系统中的一个组件，系统会向其发送满足性查询。例如，一个为机器人规划路径的程序可能会使用 SAT 求解器来查找是否存在距离当前状态 k 步以内的路径。如果答案是否定的，程序就会增加 k 步并再次尝试。这里重要的一点是，要求 SAT 求解器求解的公式序列并不是任意的：这些公式有很多共同点。我们能否利用这一事实让 SAT 求解器运行得更快？我们应该以某种方式重复使用以前收集的信息，以加快当前实例的求解速度。为了让事情更简单，请考虑两个连续求解的 CNF 公式 $C_{1}$和$C_2$，并假设在求解 $C_1$ 时已知 $C_2$。下面是求解$C_2$ 时可以重复使用的两种信息：
- **重复使用子句。** 我们应该回答下面的问题：如果 c 是在求解 $C_1$ 时学到的冲突子句，那么在什么条件下 $C_2$ 和 $C_2 ∧ c$ 是等价的？如果我们把 $C_1$ 和 $C_2$ 看作是子句的集合，就更容易回答这个问题了。让 $C$ 表示交集 $C 1 ∩ C 2$ 中的子句。在求解 $C_2$ 时，可以重复使用仅从 $C$ 子句集中学习到的任何子句。在实践中，如上述路径规划问题，序列中的连续公式非常相似，因此 $C_1$ 和 $C_2$ 共享其绝大部分子句，这意味着所学到的大部分内容都可以重复使用。
- **重复使用启发式参数**。在求解过程中会更新各种权重，用于启发式地指导搜索，例如，变量分数用于决策 ，权重表示子句在推导新子句时的活跃程度，用于确定哪些已学子句应保留，哪些应删除，等等。如果 $C_1$和 $C_2$ 足够相似，那么使用 $C_1$ 求解过程结束时的权重开始求解 $C_2$ 可以加快 $C_2$ 的求解。

Assumptions在现代SAT（可满足性）求解器中扮演重要角色，特别是在递增SAT求解过程中。它们是已知在求解特定问题（如 $C_1$） 时成立的文字，但在求解后续问题（如 $C_2$） 时可能被移除或取反。

假设（Assumptions）的机制是由MiniSAT求解器引入的。具体来说，假设是一组特定的文字，这些文字被传递给求解器作为参数。求解器将假设视为特殊的文字，并根据这些假设进行初始决策。如果求解器回溯到最后一个假设决策级别以下，它将声明公式不可满足，因为在不改变假设的情况下没有解决方案。

假设机制的关键点包括以下几个方面：

1. **初始决策**：假设文字决定了求解器的初始一组决策。例如，如果假设文字是 $a_1, a_2, \ldots, a_n$，那么求解器将开始做出 $a_1=true, a_2=true, \ldots, a_n=true$ 的决策，并按通常方式应用布尔约束传播（BCP）。如果在某一点求解器回溯到决策级别 $n$ 或以下，它将声明公式不可满足。
2. **学习子句重用**：所有学习到的子句都是独立于假设的，因此在假设不再成立时仍可以重用这些子句。这意味着可以在求解 $C_2$ 时保持在求解 $C_1$ 过程中学习到的所有子句，从而节省重新解析公式的时间。
3. **假设的添加和删除**：为了解决递增SAT问题，假设机制还允许在实例之间添加和删除子句。当需要添加子句时，求解器接收应添加的子句集（例如，$C_2 \setminus C_1$）。当需要删除子句时，可以通过向每个要删除的子句添加一个新的假设文字（对应于一个新变量）并取反来实现。例如，如果 $c = (x_1 \lor x_2)$，那么它可以被替换为 $c' = (\neg a \lor x_1 \lor x_2)$，其中 $a$ 是一个新变量。在假设 $a=true$ 的情况下，$c$ 与 $c'$ 等价，从而不会改变公式的可满足性。在求解 $C_2$ 时，将该假设替换为 $a=false$，相当于删除子句 $c$。以这种方式使用的假设文字被称为子句选择器。（个人理解：将$C_1和C_2$的子句不同转换为假设不同，使得$C_1和C_2$子句相同，所有学习到的子句可以重用）

假设机制通过上述方式提高了递增SAT求解器的效率，使其能够更快速地解决一系列相关联的SAT问题。这种机制在实际应用中非常有用，特别是在需要频繁处理相似公式的场景中，例如路径规划、调度和验证等领域。

### 2.2.8 从SAT到约束满足问题

与SAT问题的研究并行，有大量关于约束满足问题（CSP）的研究，这两个领域之间有很多相互促进的地方。CSP允许对具有有限离散域的变量施加任意约束。例如，一个CSP实例可以定义如下的变量域：$x_1 \in \{1, \ldots, 10\}$，$x_2 \in \{2, 4, 6, \ldots, 30\}$，$x_3 \in \{-5, -4, \ldots, 5\}$，以及这些变量上的布尔组合约束：

$\text{AllDifferent}(x_1, x_2, x_3) \land x_1 < x_3$

AllDifferent约束意味着其参数必须被赋予不同的值。现代CSP求解器支持几十种这样的约束。一个命题公式可以看作是CSP模型的一种特例，它不使用布尔连接词之外的约束，并且变量的域仅限于$\{0, 1\}$。

CSP求解是一个NP问题，因此可以在多项式时间内归约为SAT。由于域被限制为有限的离散域，将它们“扁平化”到命题逻辑需要一些工作。例如，具有域$\{1, \ldots, n\}$的变量可以用$\lceil \log(n) \rceil$个命题变量编码。如果域中有“空隙”，则需要对这些变量可以赋予的值添加额外的约束。同样，约束也应该被翻译成命题公式。例如，如果$x_1$用命题变量$b_1, \ldots, b_5$编码，$x_2$用$c_1, \ldots, c_5$编码，那么约束$x_1 \neq x_2$可以在命题逻辑中表示为：$\bigvee_{i=1}^{5}(b_i \lor c_i) \land (\neg b_i \lor \neg c_i)$，实际上强制要求至少有一个比特不同。AllDifferent约束就是所有参数的成对不等性。额外的位级（对数级）翻译方法将在第6章中出现，而一个更简单的线性大小翻译则是问题2.11的主题。实际上，一些竞争性CSP求解器只是前端工具，它们将CSP翻译为SAT，无论是预先翻译还是延迟翻译。其他求解器直接处理约束。

描述CSP求解器如何工作超出了本书的范围。我们只能说，它们可以用一个类似于SAT的核心构建，包括决策、约束传播和学习。然而，每种类型的约束必须分别处理。CSP求解器通常是模块化的，因此将自己喜欢的约束添加到现有的CSP求解器并不难。大部分工作在于定义约束的传播器。约束$c$的传播器是一个函数，给定$c$和变量的当前域，可以（a）推断由$c$暗示的域缩减，（b）检测$c$是冲突的，即它不能在当前域中满足。在上述示例中，$<$约束的传播器应该从$x_1 < x_3$推断出$x_1$的域应减少到$\{1, \ldots, 4\}$，因为更高的值不被$x_3$的当前域$\{ -5, \ldots, 5 \}$支持。换句话说，对于赋值$x_1 = 5$，在$x_3$的当前域中没有值可以满足$x_1 < x_3$。另一个示例，假设我们有以下CSP：

 $x_1 \in \{0, 1\}, x_2 \in \{0, 1\}, x_3 \in \{0, 1\}$
 $\text{AllDifferent}(x_1, x_2, x_3)$ 

AllDifferent的传播器应该检测到该约束在这些域下不能满足。SAT中的传播器等价于布尔约束传播（BCP）。传播器必须是可靠的，但对于某些约束，使它们完全可靠是计算上过于昂贵的（见定义1.6）。换句话说，它可能找不到所有可能的域缩减，并且在部分赋值下不总是检测到冲突。这并不影响整个求解器的完整性，因为在完整赋值时，它能够检测到冲突。

给定一个约束问题，将其建模为CSP而不是命题逻辑有两个潜在优势：

- CSP作为一种建模语言更具可读性和简洁性
- 使用不基于归约为SAT的CSP求解器，可以利用某些约束（如AllDifferent）具有多项式时间精确传播器的事实，而将相同的约束归约为命题逻辑后求解在最坏情况下是指数级的

然而，这两个优势通常在实践中并不明显，因为（a）大多数工业应用的问题是自动生成的，因此可读性并不重要，且（b）现实中的约束问题包含多种类型的约束，解决它们仍然是指数级的。当前的观点是，CSP和SAT在运行时间上并无显著差异，这更多是一个谨慎工程的问题，而不是实质性的问题。

### 2.2.9 SAT求解器：总结

SAT求解器通过使用冲突驱动的子句学习（CDCL）算法，显著提高了求解SAT问题的效率。CDCL的核心思想是基于冲突分析来学习新的子句，从而剪枝搜索空间并避免重复搜索。在CDCL框架下，SAT求解器通常包含以下几个关键组件：

1. **布尔约束传播（BCP）**：这是SAT求解器的基本传播机制，用于推导变量的赋值并检测冲突。BCP通过遍历当前部分赋值，传播已知的约束，并确定其他变量的赋值。

2. **冲突分析和学习**：当BCP检测到冲突时，求解器会分析冲突并学习一个新的子句（冲突子句），该子句可以防止相同的冲突再次发生。冲突分析的核心是使用反向推理，从冲突中找出导致冲突的最小变量集。

3. **决策启发式**：SAT求解器使用各种启发式方法来选择下一个要赋值的变量。这些启发式方法的目的是最大化传播效果，最小化冲突的可能性。常见的启发式方法包括VSIDS（可变状态独立衰减计数器）和活动变量计数。

4. **回溯机制**：当检测到冲突且无法通过当前赋值解决时，求解器会回溯到上一个决策点，并尝试其他可能的赋值。回溯的深度通常由冲突分析的结果决定。

5. **重启策略**：为了避免陷入局部最优解或长时间停留在某个搜索路径上，SAT求解器会周期性地重新开始搜索（重启），但保留已学习的子句以加速新的搜索。

让我们反思一下我们在第1.1节中描述的两种形式化推理方法——演绎和枚举。我们能否说SAT求解器，如本节所述，遵循其中之一呢？一方面，SAT求解器可以被认为是在一个具有$2^n$个叶子的二叉树中进行搜索，其中$n$是输入公式中的布尔变量的数量。每个叶子是一个完整的赋值，因此，遍历所有叶子对应于枚举。从这个角度来看，冲突子句是为了修剪搜索空间而生成的。另一方面，冲突子句是通过其他子句的分解规则推导出来的。如果公式是不可满足的，那么这种规则的应用序列，如SAT求解器的日志中所列，是不可满足性的演绎证明。因此，这两种观点都是合法的。

### Problems
书本$P_{50}$
题目很好，共18道，推荐去做

# 3 从命题逻辑到无量词逻辑



## 3.1 介绍


$$(x_1 = x_2 ∨ x_1 = x_3) ∧ (x_1 = x_2 ∨ x_1 = x_4) ∧ x_1 ≠ x_2 ∧ x_1 ≠ x_3 ∧ x_1 ≠ x_4$$

$$((x_1 + 2x_3 < 5) ∨ ¬(x_3 ≤ 1) ∧ (x_1 ≥ 3))$$

$$(i = j ∧ a[j] = 1) ∧ ¬(a[i] = 1)$$

相等性、线性谓词、数组……是否存在一个通用框架来定义它们？当然有，这就是一阶逻辑。上面的每个例子都是某个一阶理论的无量词片段中的公式。让我们回顾一下在1.4节中已经介绍过的一些基本术语。通常，这些公式可以使用命题连接词和一组额外的函数和谓词符号$Σ$，这些符号唯一地定义了理论T——事实上，$Σ$被称为T的签名。T的决策程序可以决定T公式的有效性。因此，这些公式可以被描述为T有效、T可满足（也称为T一致）等。

在本章中，我们研究了一种通用方法——实际上是一个框架——它将CDCL泛化为一个可判定的无量词一阶理论的决策程序，例如上面提到的那些。这种方法通常被称为**DPLL(T)**，强调它是由理论T参数化的。之所以称之为DPLL(T)而不是CDCL(T)仅仅是由于历史原因：它基于现代的CDCL求解器（见2.4节关于差异的讨论）。它在大多数**可满足性模块理论**（**SMT**）求解器中实现。例如，在公式(3.1)的情况下，T只是相等理论（见第4章）。DPLL(T)基于SAT求解器和T的合取片段的决策程序DPT之间的相互作用，即那些是T文字的公式的合取。

以下例子展示了存在一个用于处理等式合取的决策程序DPT的情况：

**例子 3.1** 在T是相等理论的情况下，设计一个简单的$DP_T$是容易的。T-文字要么是某些变量集V上的等式要么是不等式谓词。给定T-文字的合取公式ϕ，构建一个无向图$G(N, E_=, E_≠)$，其中节点N对应于变量V，并且有两种边，$E_=和E_≠$，分别对应于公式$ϕ$中的等式和不等式谓词。这被称为*等式图*。可以很容易地看出，如果存在一条边$(v1, v2) ∈ E_≠$使得v2可以通过$E_=$边的序列从$v_1$到达，则公式$ϕ$不可满足。图3.1中的等式图对应于公式$x_1 ≠ x_2 ∧ x_2 = x_3 ∧ x_1 = x_3$。这种程序可以通过在图G上进行$|E_≠|$次深度优先搜索（DFS）调用来实现，因此在输入公式的大小上是多项式时间的。更高效的程序存在，并将在第4章讨论。

![image.png|260](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240516160657.png)


图3.1 对应于公式$x_1 ≠ x_2 ∧ x_2 = x_3 ∧ x_1 = x_3$的等式图

为了推理具有任意命题结构而不仅仅是合取的公式，我们可以简单地执行分案例（见1.3节），并用$DP_T$决定每个案例。如果任何一个案例是可满足的，那么原始公式也是可满足的。例如，为了决定公式(3.1)，需要考虑四个案例：

1. $x_1 = x_2 ∧ x_1 = x_3 ∧ x_1 ≠ x_2 ∧ x_1 ≠ x_3 ∧ x_1 ≠ x_4$
2. $x_1 = x_2 ∧ x_1 = x_4 ∧ x_1 ≠ x_2 ∧ x_1 ≠ x_3 ∧ x_1 ≠ x_4$
3. $x_1 = x_3 ∧ x_1 = x_2 ∧ x_1 ≠ x_2 ∧ x_1 ≠ x_3 ∧ x_1 ≠ x_4$
4. $x_1 = x_3 ∧ x_1 = x_4 ∧ x_1 ≠ x_2 ∧ x_1 ≠ x_3 ∧ x_1 ≠ x_4$

所有这些都不可满足。因此，我们可以得出结论，公式(3.1)是不可满足的。

这种方法的主要问题在于，案例的数量通常是原始公式大小的指数级的——想想如果原始公式有n个子句，我们将有多少案例——实际上，当试图用这种方法解决具有非平凡命题结构的公式时，案例的数量通常是一个主要瓶颈。此外，这种方法错过了任何学习的机会，因为每个案例都是独立解决的。在上面的例子中，矛盾$x_1 = x_2 ∧ x_1 ≠ x_2$出现在两个独立的案例中，但我们仍然需要分别推导每个案例的不一致性。

一种更优的方法是利用SAT求解器的学习能力（参见第35页）和其他优化手段，并将其与$DP_T$结合起来以解决这些公式。在这个框架中，两个主要的引擎紧密协作：SAT求解器选择需要满足的文字，以满足公式的布尔结构，而$DP_T$负责检查这些选择是否在理论T中可满足。

这种方法的优点在于，关于公式$ϕ$的命题部分的推理全部由命题SAT求解器执行；因此，避免了显式地对$ϕ$中的析取进行分支。这在实践中具有显著优势，因为由此产生的算法既模块化又高效。

现在，我们将详细介绍如何实现这种组合，同时继续以等式理论为例。



## 3.2 DPLL(T) 概述

DPLL(T)是一种用于处理一阶逻辑公式的方法，它结合了命题逻辑的DPLL算法（Davis-Putnam-Logemann-Loveland）和特定理论T的决策程序。这个方法能够有效地解决包含特定结构（如等式、不等式、线性算术等）的公式。
思路：将无量词一阶逻辑转换为**命题骨架**（命题逻辑），使用SAT得到满足命题骨架的赋值，再使用$DP_T$判断该赋值在一阶逻辑情况下是否可能成立，如果不能成立，则向命题骨架中添加**阻塞子句**。

#### 关键概念

1. **签名 $\Sigma$**：定义了理论T中使用的符号集合，包括常量、函数和谓词符号。
2. **$\Sigma$-原子**：由签名$\Sigma$中的符号构成的基本逻辑表达式，如等式或谓词应用。
3. **命题骨架**：将一阶逻辑公式中的$\Sigma$-原子替换为布尔变量，得到的布尔公式。

#### 过程概述

1. **公式转换**：将一阶逻辑公式转换为其命题骨架。对于每个$\Sigma$-原子，用布尔变量表示。例如，公式$\varphi := x = y \lor x = z$的命题骨架为$e(\varphi) := e(x = y) \lor e(x = z)$。
2. **SAT求解**：将命题骨架传递给SAT求解器，检查其可满足性。如果SAT求解器找到一个可满足的赋值$\alpha$，则继续检查该赋值在理论T下的可满足性。
3. **理论检查**：用决策程序DPT检查SAT求解器返回的赋值是否在理论T下可满足。如果不可满足，则生成一个**阻塞子句**（引理），该引理描述了导致冲突的条件，并将其添加回SAT求解器。
4. **重复过程**：SAT求解器重新运行，考虑新的阻塞子句，直到找到一个在理论T下可满足的赋值，或确定公式不可满足。

#### 示例

假设公式$\varphi := x = y \land ((y = z \land \neg(x = z)) \lor x = z)$，其命题骨架为$e(\varphi) := e(x = y) \land ((e(y = z) \land \neg e(x = z)) \lor e(x = z))$。将该命题骨架传递给SAT求解器，假设求解器返回赋值$\alpha := \{e(x = y) \mapsto \text{true}, e(y = z) \mapsto \text{true}, e(x = z) \mapsto \text{false}\}$。这个赋值在理论T下不可满足，因此生成阻塞子句$(\neg e(x = y) \lor \neg e(y = z) \lor e(x = z))$，并将其添加回SAT求解器。

DPLL(T)方法有许多改进和变体。例如，可以在部分赋值时调用决策程序DPT，而不是等待完整赋值，从而生成更强的引理。此外，理论传播可以与布尔约束传播（BCP）结合，进一步提高求解效率。

![1715849565.216955.png](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/1715849565.216955.png)

### 3.3 形式化DPLL(T)

在这一部分，我们将形式化地描述如何使用DPLL(T)算法来决定一个给定理论 $T$ 的公式 $\varphi$ 是否可满足。

#### 关键概念

1. **命题骨架（Propositional Skeleton）**：将一阶逻辑公式中的 $\Sigma$-原子替换为布尔变量，得到的布尔公式。例如，公式 $\varphi := x = y \lor x = z$ 的命题骨架为 $e(\varphi) := e(x = y) \lor e(x = z)$。
2. **赋值（Assignment）**：赋值可以是完全的或部分的，表示为 $\alpha$。例如，对于赋值 $\alpha := \{e(x = y) \mapsto \text{true}, e(y = z) \mapsto \text{true}, e(x = z) \mapsto \text{false}\}$。
3. **理论检查（Theory Checking）**：使用决策程序DPT检查SAT求解器返回的赋值是否在理论 $T$ 下可满足。如果不可满足，则生成一个阻塞子句，并将其添加回SAT求解器。

#### 算法描述

我们将通过迭代求解一个布尔公式 $B$ 来决定一个给定理论 $T$ 的公式 $\varphi$ 是否可满足。算法逐步强化 $B$，通过添加由DPT计算的约束的编码。

算法的步骤如下：

1. 初始设定 $B = e(\varphi)$。
2. 进入循环，每次迭代执行以下步骤：
   - 使用SAT求解器求解布尔公式 $B$，得到一个赋值 $\alpha$ 和结果 $res$。
   - 如果 $B$ 是不可满足的，则 $\varphi$ 也是不可满足的，算法返回“不可满足”。
   - 否则，使用决策程序DPT检查 $T^h(\alpha)$ 是否可满足。DPT返回一个约束和结果 $res$。
   - 如果 $T^h(\alpha)$ 可满足，则 $\varphi$ 是可满足的，算法返回“可满足”。
   - 否则，将$DP_T$返回的引理 $t$ 添加到 $B$ 中，并继续迭代。

算法的伪代码如下：

![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240516165543.png)

- **公式 $t$ 的要求**：
   1. $t$ 在理论 $T$ 中是有效的。
   2. $t$ 中的原子限制为出现在 $\varphi$ 中的原子。
   3. $t$ 的编码与 $\alpha$ 矛盾，即 $e(t)$ 是一个阻塞子句。

第1条保证了可靠性，第2，3条保证了算法会终止，特别地，第3条保证了$\alpha$不会重复

不过，其中的两条要求可以被弱化,弱化后结果如下：
要求1：$t$可以是任何被$\varphi$蕴含的公式，而不一定要是T-有效公式。然而，要找到一方面由 $|varphi$ 所隐含，另一方面又能满足其他两个要求的公式，其难度可能不亚于决定 $|varphi$ 本身，这就失去了意义。在实践中，需要针对每种理论和决策程序分别调整计算 t 的工作量，以最大限度地提高整体性能。
要求2：公式 $t$ 可以指涉在 $\varphi$ 中未出现的原子，只要这些新原子的数量是有限的。例如，在等式逻辑中，我们可以允许 $t$ 指涉所有形式为 $x_i = x_j$ 的原子，其中 $x_i, x_j$ 是 $\varphi$ 中的变量，即使这些等式谓词只在 $\varphi$ 中部分出现。

#### 整合到CDCL中

设 $B_i$ 是算法3.3.1中循环的第 $i$ 次迭代中的公式 $B$。在所有 $i \geq 1$ 的情况下，约束 $B_{i+1}$ 都比 $B_i$ 更强，因为阻塞子句在迭代之间被添加但不被删除。很容易看出，这意味着在解决 $B_i$ 时学习到的任何冲突子句在解决 $B_j$ 时都可以重用，其中 $i < j$。事实上，这是增量可满足性的一个特例，大多数现代SAT求解器都支持这种特性。因此，在第4行调用增量SAT求解器可以提高算法的效率。

更好的选择是将Deduction（推理）整合到CDCL-SAT算法中，如算法3.3.2所示。该算法使用了一个AddClauses（添加子句）过程，该过程在运行时将新子句添加到当前子句集合中。我们将为什么这比使用增量SAT求解器更好的问题留给读者（见问题3.1）。我们注意到，第9行中提到的 $ \alpha $ 是当前对命题变量的赋值。

## 3.4 理论传播和DPLL(T)框架

### 3.4.1 传播理论推论

**算法3.3.2可以进一步优化。例如，考虑包含整数变量$x_1$的公式$\phi$，其中包括文字$x_1 \ge 10$和$x_1 < 0$。**

假设Decide过程将$e(x_1 \ge 10)$赋值为true，并将$e(x_1 < 0)$赋值为true。不可避免地，任何对Deduction的调用都会导致这两个事实之间的矛盾，而不考虑其他任何决策。然而，算法3.3.2在找到完全满足的赋值之前不会调用Deduction。因此，完成赋值所花费的时间被浪费了。此外，如本章介绍中提到的，这种完全赋值的驳斥可能是由于其他原因（即，证明赋值的不同子集是矛盾的），因此，包含相同错误赋值的其他附加赋值（如$e(x_1 \ge 10)$和$e(x_1 < 0)$）不会被排除。

**因此，可以通过在编码器的完全赋值可用之前运行Deduction来改进算法3.3.2。**

这种提前调用Deduction的做法有两个目的：

1. **尽早排除矛盾的部分赋值。**
2. **可以将仍未赋值的文字的推论传回给SAT求解器，如第3.2节所示。继续我们的例子，一旦$e(x_1 \ge 10)$被赋值为true，我们可以推断出$e(x_1 < 0)$必须为false，从而完全避免冲突。**

这将我们引向算法的下一个版本，称为DPLL(T)，这是由Tinelli首次以抽象形式引入的。与算法3.3.1和3.3.2一样，该算法的组成部分是CDCL和一个特定理论的合取片段的决策程序。名称DPLL(T)（如上所述，也可以称为CDCL(T)）强调这是一个可以用不同理论和相应决策程序实例化的框架。
![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240517163651.png)
在算法3.4.1中呈现的DPLL(T)版本中（参见图3.3），在BCP无法再进行进一步推论之后，在第9行调用Deduction。然后它找到理论推导出的文字，并将它们以约束t的形式传达给CDCL求解器。因此，除了布尔域中的推论外，现在还存在由于理论T的推论。

![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240517163419.png)

理论传播（Theory Propagation）的要求是什么？与以前一样，它们必须由公式$\phi$隐含，并且仅限于有限的原子集合——通常是$\phi$的原子。希望，当$T̂h(α)$不满足时，$e(t)$阻止赋值$\alpha$；这不是强制性的，因为它是否阻止$\alpha$不影响正确性——Deduction只需要在$\alpha$是完全赋值时是完整的。某些SMT求解器利用这一事实对部分赋值执行便宜的检查，例如限制它们的时间。如果$T̂h(α)$是可满足的，则我们要求t满足以下两个条件之一以保证终止：

1. 在赋值$\alpha$下，子句$e(t)$是断言子句（asserting clause）（断言子句在第2.2.3节中定义）。这意味着将$e(t)$添加到B并调用BCP会导致某个文字的编码器赋值。
2. 当Deduction找不到上述定义的断言子句t时，t和$e(t)$等效为真。

第二种情况，例如当所有布尔变量已经赋值时发生，因此公式被认为是可满足的。在这种情况下，满足第11行的条件，并且过程从第13行继续，重新调用Decide。由于所有变量已经赋值，因此过程返回“可满足”。

**示例3.3：**

再次考虑两个编码器$e(x_1 \ge 10)$和$e(x_1 < 0)$的例子。将其中一个设置为true后，Deduction过程检测到$\neg(x_1 < 0)$被隐含，换句话说，$$t := \neg(x_1 \ge 10) \lor \neg(x_1 < 0)$$是理论有效的。相应的编码（断言）子句为$$e(t) := (\neg e(x_1 \ge 10) \lor \neg e(x_1 < 0))$$。

### 3.4.2 性能，性能...

回顾一下，当赋值$\alpha$是部分赋值时，Deduction会检查理论方面是否存在矛盾，如果不存在矛盾，则执行理论传播（theory propagation）。

为了性能，在此步骤中通常更好地运行一个近似算法来寻找矛盾。事实上，只要$\alpha$是部分赋值，就不需要一个完备的程序来决定可满足性。这并不会改变整体算法的完备性，因为当$\alpha$是完全赋值时会进行完整的检查。一个很好的例子是当理论是整数线性算术时，竞争性求解器的做法（将在第5.3节讨论）。决定该理论的合取片段是NP完全的，因此它们仅考虑问题的实数松弛（这意味着它们将变量视为实数$R$而不是整数$Z$），这可以在多项式时间内解决。这意味着Deduction有时会错过矛盾，因此不会返回阻塞子句（blocking clause）。

另一个性能考虑与理论传播有关。重要的是要注意，理论传播不是为了正确性，而只是为了效率。因此，计算新隐含结果所投入的努力需要调整，以实现最佳的整体性能。

**穷尽理论传播（Exhaustive Theory Propagation**一词是指找到并传播所有由$T̂ h(\alpha)$隐含的文字的过程。一种简单而通用的方法（称为“深入”）来执行理论传播如下：给定一个未赋值的理论原子$a_i$，检查$T̂ h(\alpha)$是否隐含$a_i$或$\neg a_i$。以这种方式检查的未赋值原子集合取决于我们希望理论传播的穷尽程度。

**示例3.4**：考虑等式逻辑，以及我们在示例3.1中使用的符号。在等式逻辑中执行穷尽理论传播的一种简单方法如下：对于每个形式为$x_i = x_j$的未赋值原子，检查当前的部分赋值是否在$E_=$中形成了$x_i$和$x_j$之间的路径。如果是，则此原子由路径中的文字隐含。如果部分赋值形成了不等路径（路径中恰好有一条边来自$E \neq$），则该原子的否定被隐含。

然而，这种通用方法通常不是最有效的。在许多情况下，更好的策略是只执行简单的、廉价的传播，而忽略更昂贵的传播。例如，在线性算术的情况下，实验表明，穷尽理论传播对整体性能有负面影响。在这种情况下，更有效的方法是寻找简单易得的隐含结果，例如“如果$x > c$成立，其中$x$是一个变量，$c$是一个常数，那么如果$d < c$，则任何形式为$x > d$的文字都是隐含的。”￼

### 3.4.3 返回隐含赋值而非子句

一种优化理论传播的方法是改变Deduction发现信息的传播方式。传统上，Deduction会返回一个理论有效的子句$t$。例如，如果$\alpha$使得$T̂ h(\alpha)$隐含一个文字$lit$，那么：

$$t := (lit \lor \neg T̂ h(\alpha))$$

编码子句$e(t)$的形式为：

$$e(t) := \left( e(lit) \lor \bigvee_{lit' \in T̂ h(\alpha)} \neg e(lit') \right)$$

然而，这种方法效率低下，实验表明这些子句很少被重复使用并且增加了处理负担。因此，提出了一种更有效的替代方案，即Deduction返回一个隐含赋值的列表（例如包含$e(lit)$），由SAT求解器执行。

这些隐含赋值在$B$中没有前提子句，这与标准的布尔约束传播（BCP）不同。这在Analyze-Conflict过程中引发了问题，因为它依赖前提子句来推导**冲突子句**。为了解决这个问题，当Analyze-Conflict需要这些隐含文字的前提时，它会查询决策程序以获取解释，即部分赋值在创建赋值时隐含该文字的子句。

解释的子句可能与最初的子句相同，但不一定如此。为了效率，典型的Deduction实现不会保留这些子句，因此需要生成新的解释。例如，在等式逻辑中解释隐含文字$x = y$时，需要在等式图中搜索$x$和$y$之间的路径，其中所有边在识别和传播该隐含时都存在于图中。

### 3.4.4 生成强引理

当$T̂ h(\alpha)$不可满足时，Deduction会返回一个阻塞子句$t$，以消除赋值$\alpha$。$t$越强，它能消除的不一致赋值就越多。获得更强公式的一种方法是构造一个包含参与$T̂ h(\alpha)$不可满足性证明的文字的否定的子句。换句话说，如果$S$是作为不可满足性证明前提的文字集合，那么阻塞子句是：

$$t := \bigvee_{l \in S} \neg l$$

计算集合$S$对应于计算公式的不可满足核心。给定一个不可满足性的演绎证明，核心很容易找到。为此，可以将这种证明表示为一个有向无环图。在这种图中，节点标记为文字，一条边$(n_1, n_2)$表示标记节点$n_1$的文字用于推导标记节点$n_2$的文字。在这种图中，有一个标记为false的单一汇节点，根节点标记为证明的前提（可能还有公理）。从false节点反向遍历可以到达的根集合对应于不可满足核心。
![|635](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240517202821.png)
不可满足核心在第2.2.6节中定义，适用于命题CNF公式。这里的简要讨论将这一早期定义推广到二元解析图以外的推理规则。

### 即时传播

现在考虑一种算法的变体，在每次对编码变量进行新的赋值后（可能是由于决策或BCP推论），而不是让BCP先完成，调用Deduction。此外，假设我们正在实施如上所述的穷尽理论传播。在这种变体中，调用Deduction不能导致冲突，这意味着它永远不需要返回阻塞子句。这一观察的形式证明留作练习（问题3.5）。一个非正式的理由是，如果对单个编码器的赋值使$Th(\alpha)$不可满足，则该赋值的否定将在上一步由Deduction推导并传播。例如，如果编码器$e(x=y)$被推导并传递给Deduction，则此文字只能在根据先前部分赋值在$x$和$y$之间存在不等路径（这些路径在例3.4中讨论）时引起冲突。这意味着在上一步中，$\neg e(x=y)$应该已经传播到求解器的布尔部分。

## 3.5 问题

  

**问题3.1** （Lazy-CDCL的增量性）。回忆一下，增量SAT求解器是知道在给定与之前问题相似的问题时哪些冲突子句可以重用的（即，某些子句被添加，其他子句被删除）。算法3.3.2（Lazy-CDCL）与将算法3.3.1中的第4行替换为调用增量SAT求解器有何不同？

  

**问题3.2** （算法3.3.1–3.4.1的优化？）
1. 考虑算法3.3.1–3.4.1的以下变体，用于以NNF形式给出的输入公式$\phi$（否定被推入到原子中，例如$\neg(x=y)$以$x \neq y$的形式出现）。而不是将$Th(\alpha)$发送给Deduction，而是发送
$$\bigwedge T_{hi}$$
对于所有$i$，使得$\alpha(e_i) = \text{true}$。例如，给定赋值
$$\alpha := {e(x=y) \mapsto \text{true}, e(y=z) \mapsto \text{false}, e(x=z) \mapsto \text{true}}$$
检查$x=y \wedge x=z$
这种变体是否正确？证明其正确性或给出反例。展示一个示例，其中上述变体减少了Deduction和SAT求解器之间的迭代次数。

  

**问题3.3** （理论传播）。设$DP_T$是用于$\Sigma$-文字合取的决策过程。建议一个使用$DP_T$执行穷尽理论传播的过程。

  

**问题3.4** （DPLL(T)变体的伪代码）。回忆第3.4.5节末尾建议的DPLL(T)变体，其中部分赋值在每次对编码器进行赋值后而不是仅在BCP之后发送给理论求解器。为此算法编写伪代码，并以图3.3的样式绘制相应的图。

  

**问题3.5** （穷尽理论传播）。在第3.4.5节中，声称通过穷尽理论传播，Deduction中不会发生冲突，因此Deduction永远不会返回阻塞子句。证明这一主张。

## 3.7 术语表

### 3.7 术语表

以下是3.7章节的术语表以及它们的定义：

| 术语                 | 定义                           |
| ------------------ | ---------------------------- |
| $DP_T$             | 用于$\Sigma$-文字合取的决策过程。        |
| $e(a)$             | 编码器，表示布尔变量和原子之间的映射。          |
| $\alpha(t)$        | 赋值函数，将变量映射到值。                |
| $at(\phi)$         | 公式$\phi$中的原子集合。              |
| $at_i(\phi)$       | 公式$\phi$中的第$i$个原子。           |
| $\alpha$           | 赋值，通常表示部分赋值。                 |
| $Th(at_i, \alpha)$ | 在赋值$\alpha$下，原子$at_i$的理论解释。  |
| $Th(\alpha)$       | 在赋值$\alpha$下，所有原子的理论解释。      |
| $\hat{T}h(\alpha)$ | 在赋值$\alpha$下，所有原子的理论解释的合取。   |
| $B$                | 布尔公式。在这个章节，被初始化为$e(\varphi)$ |
| $t$                | 阻塞子句，用于避免当前赋值的冲突。            |
| $B_i$              | 公式$B$在算法3.3.1的第i次循环后的结果      |


# 4 等价逻辑和未解释函数

## 4.1 介绍

### 4.1.1 复杂度和表达性

等价逻辑和命题逻辑都是NP完全的，意味他们可以建模一样的决策问题（变量数量的多项式差异不大），所以我们为什么两个都学习？
原因有二：建模的便利性，效率。

### 4.1.2 布尔变量

等式逻辑公式中经常混合使用布尔变量。然而，为了保持算法描述的简单性，我们不将它们纳入理论定义中。可以通过将每个布尔变量替换为两个新变量之间的等式来轻松地从输入公式中消除布尔变量。但这不是一个非常高效的解决方案。随着本章的进展，将会清楚地看到，通过对各种决策过程进行一些小的修改，可以直接处理布尔变量。对于本书中讨论的许多其他理论，这个观察结果同样适用。

### 4.1.3 移除常量：简化

定理4.2. 给定一个等式逻辑公式 $\phi_E$，存在一个算法在多项式时间内生成一个没有常量的等式可满足公式 $\phi_E'$。

#### 算法4.1.1: 移除常量

输入：一个包含常量 $c_1, \ldots, c_n$ 的等式逻辑公式 $\phi_E$
输出：一个等式逻辑公式 $\phi_E'$，使得 $\phi_E'$ 和 $\phi_E$ 是等式可满足的，且 $\phi_E'$ 没有常量

1. 令 $\phi_E' := \phi_E$
2. 在 $\phi_E'$ 中，将每个常量 $c_i$（$1 \le i \le n$）替换为一个新变量 $C_{c_i}$
3. 对于每对常量 $c_i, c_j$（$1 \le i < j \le n$），在 $\phi_E'$ 中添加约束 $C_{c_i} \neq C_{c_j}$

算法4.1.1 通过用新变量替换常量来消除给定公式中的常量。问题4.1和4.2 关注此过程。除非另有说明，否则从此以后我们假设输入的等式公式不包含常量。

### 4.2 Uninterpreted Functions

等式逻辑如果结合未解释函数使用，将会变得更加有用。未解释函数用于对定理进行抽象或概括。与其他函数符号不同，它们不应作为公式模型的一部分进行解释。例如，在以下公式中，$F$ 和 $G$ 是未解释的，而二元函数符号“+”被解释为通常的加法函数：

$$F(x) = F(G(y)) \lor x + 1 = y \ .$$

**定义 4.3** (带未解释函数的等式逻辑 (EUF))：带有未解释函数和未解释谓词的等式逻辑公式定义如下语法：

$$
\begin{aligned}
&\text{formula} : \text{formula} \land \text{formula} \ |\  \neg \text{formula} \ |\ (\text{formula}) \ |\ \text{atom} \\
&\text{atom} : \text{term} = \text{term} \ |\ \text{predicate-symbol} (\text{list of terms}) \\
&\text{term} : \text{identifier} \ |\ \text{function-symbol} (\text{list of terms})
\end{aligned}
$$

我们通常用大写字母表示未解释函数，并用上标“UF”表示 EUF 公式。

```ad-note 
**附注：逻辑视角**
要从逻辑的角度解释未解释函数的含义，我们必须回到理论的概念，这在 1.4 节中解释过。回想一下公理集 (1.35)，在本章中我们指的是无量词的部分。

只需要一个额外的公理（实际上是一个公理模式）就可以将等式逻辑扩展到 EUF。对于每个 $n$ 元函数符号，$n > 0$：

$
\begin{aligned}
&\forall t_1,\ldots,t_n,t_1^{\prime},\ldots,t_n^{\prime}.\\&\bigwedge_it_i=t_i^{\prime}\implies F(t_1,\ldots,t_n)=F(t_1^{\prime},\ldots,t_n^{\prime})\quad\text{(CONGRUENCE) ,}
\end{aligned}
$

其中 $t_1, \ldots, t_n, t'_1, \ldots, t'_n$ 是新变量。对于未解释谓词，也可以定义类似的公理。

因此，在函数符号被解释的理论中，有公理定义它们的语义——我们希望它们的含义。在未解释函数的理论中，满足解释的唯一限制是功能一致性所施加的限制，即一致性规则施加的限制。
```

### 4.2.1 如何使用未解释函数

在给定公式中用未解释函数替换函数是常见的技术，可以使推理过程（例如证明其有效性）变得更容易。但与此同时，这个过程使公式变得更弱，这意味着它可能会使一个有效的公式变为无效。这个观察结果总结在以下关系中，其中$\phi_{UF}$是通过将一些或全部函数替换为未解释函数从公式$\phi$派生出来的：

$\models\varphi^{\mathrm{UF}}\Longrightarrow\models\varphi\mathrm{~.}$

未解释函数在微积分和其他数学分支中被广泛使用，但在推理和验证的背景下，它们主要用于简化证明。在某些条件下，未解释函数使我们在忽略一些或所有函数的语义的情况下对系统进行推理，假设这些语义对证明不是必需的。忽略一个函数的语义是什么意思？一个正式的解释在79页的旁注中有简要说明。一个理解这个问题的方法是通过函数可以被定义的公理来观察。忽略函数的语义意味着解释不需要满足这些公理来满足公式。它唯一需要满足的是一个公理，声明未解释函数（如同任何函数一样）是一致的，即给定相同的输入，它返回相同的输出。这就是函数一致性（也称为函数一致性规则）的要求：

**函数一致性：** 同一函数的实例在给定相同参数时返回相同的值。

在许多情况下，感兴趣的公式无论函数的解释如何都是有效的。在这些情况下，未解释函数显著简化了证明，尤其是在使用自动定理证明器进行机械证明时。

假设我们有一种方法来检查EUF公式的有效性。基于这一假设，使用未解释函数的基本方案如下：

1. 设$\phi$表示一个具有解释函数的感兴趣公式。假设$\phi$的有效性检查在计算上太难，甚至不可能。

2. 给$\phi$中的每个解释函数分配一个未解释函数。用被映射的未解释函数替换$\phi$中的每个函数。将新的公式表示为$\phi_{UF}$。

3. 检查$\phi_{UF}$的有效性。如果它是有效的，则返回“$\phi$是有效的”（这由(4.3)证明）。否则，返回“不知道”。

第2步的转换当然是有代价的，因为它丢失了信息。如前所述，这导致程序不完备，即使原始公式属于可判定的逻辑。当存在一个输入公式的决策过程但解决它在计算上太难时，可以设计一个过程中逐步将未解释函数替换回它们的解释版本。我们将在第4.4节中进一步讨论这个选项。


### 4.2.2 示例：证明程序等价

证明程序等价，即证明对于相同的input，返回相同的output。

![image.png](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240518131350.png)

一般来说，证明程序等价是不可决策的，即不存在可靠且完备的方式证明这样的等价性。不过在这个例子里，等价性是可以被决策的。一个关于这些程序的重要观察是，它们只有有界循环，因此计算它们的输入输出关系是可能的。可以通过如下方式计算它们的关系：
1. 删除变量声明和返回语句
2. 展开for循环
3. 使用新辅助变量替换每个赋值的左侧变量
4. 无论在何处读取变量（在表达式中被引用），都要将其替换为上次分配给它的辅助变量。
5. 连接所有程序语句。

这些操作最终会产生两个公式$\varphi _a$和$\varphi _b$,如下图所示：
![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240518132151.png)
证明两个程序I/O等价，等价于证明下面公式的有效性：
$in0_a=in0_b\wedge\varphi_a\wedge\varphi_b\implies out2_a=out0_b\mathrm{~.}$

由于乘法计算的困难性，我们可以使用未解释函数来帮助我们证明程序等价，因此我们可以将$\varphi _a$转化为$\varphi ^{UF}_a$，$\varphi _b$转化为$\varphi ^{UF}_b$
![image.png](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240518132841.png)
让我们把例子变得更具有挑战性。考虑下面两个程序，输入是一个指向列表的指针：
![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240518133557.png)
![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240518133610.png)

此时，只确保输入是一样的是不够的，因为影响两个程序输出的不是绝对地址，而是这些地址上的数据。因此，我们需要强制两个程序读取的、在进入函数时根植于 "in "的数据在同构位置上必须是相同的。例如，两个程序都会读取 $in \rightarrow n \rightarrow data$的值，因此两边的值应该相同。我们使用*未解释函数*来执行这一条件。在这种情况下，我们需要两个这样的函数，分别称为 list_n 和 list_data，与 list 中的两个字段相对应。

![](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240518134214.png)

顺便提一下，我们还有其他方法来证明这两个程序的等价性。在这种情况下，替换就足够了：只需将 out2_a 替换为 out1_a∗in，out1_a 替换为 out0_a∗in，out0_a 替换为 in，我们就能自动证明（4.4），因为我们得到的表达式在语法上是相等的。然而，在许多情况下，这种替换并不有效，因为它会使公式的大小呈指数增长。此外，仅靠替换也可能不足以证明等价性。例如，请看 power3 con 和 power3 con new 这两个函数：

![image.png](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240518134954.png)
通过替换，我们获得两个表达式：
$out_a=con?\left((con?in*in:in)*in\right):(con?in*in:in)$
和
$out_b=con?\mathrm{~}(in*in)*in:in\mathrm{~},$
对应两个函数。这两个表达式不仅在语法上不等同，而且第一个表达式随着迭代次数的增加呈指数增长。

### 4.3 使用同余闭包决定等式和无解释函数的合取式

我们现在展示一种解决等式和无解释函数合取式的方法，该方法由Shostak于1978年提出。对于本书中考虑的大多数理论，合取谓词的可满足性问题可以在多项式时间内解决。回忆一下，我们在求解没有常量的公式的可满足性问题，因为可以使用例如算法4.1.1的方法去除常量。

从变量和无解释函数的等式和不等式构成的合取式$\varphi_{UF}$开始，Shostak的算法分为两个阶段（见算法4.3.1），基于计算等价类。这里展示的算法版本假设无解释函数只有一个参数。扩展到一般情况留作练习（问题4.5）。

#### 算法 4.3.1: 同余闭包

**输入：** 变量和无解释函数上的等式谓词合取式$\varphi^{UF}$  
**输出：** 如果$\varphi^{UF}$可满足，返回“可满足”；否则返回“不可满足”。

1. 构建同余闭合的等价类。
   (a) 初始时，如果$\varphi^{UF}$中存在谓词$(t_1 = t_2)$，则将两个项$t_1, t_2$（可以是变量或无解释函数实例）放入它们自己的等价类。所有其他变量形成单元素等价类。
   (b) 如果两个等价类共享一个项，则合并它们。重复此步骤直到没有更多可以合并的类。
   (c) 计算同余闭包：对于两个项$t_i, t_j$，如果它们在同一个类中，并且对于某个无解释函数$F$，$\varphi^{UF}$中包含项$F(t_i)$和$F(t_j)$，则合并$F(t_i)$和$F(t_j)$所在的类。重复此步骤直到没有更多此类实例。

2. 如果$\varphi^{UF}$中存在不等式$t_i \neq t_j$，且$t_i$和$t_j$在同一个等价类中，返回“不可满足”。否则返回“可满足”。

#### 例子 4.4
考虑如下合取式：
$$
\varphi^{UF} := x_1 = x_2 \land x_2 = x_3 \land x_4 = x_5 \land x_5 \neq x_1 \land F(x_1) \neq F(x_3)
$$

初始时，等价类为：
$$
\{x_1, x_2\}, \{x_2, x_3\}, \{x_4, x_5\}, \{F(x_1)\}, \{F(x_3)\}
$$

算法4.3.1的步骤1(b)合并了前两个类：
$$
\{x_1, x_2, x_3\}, \{x_4, x_5\}, \{F(x_1)\}, \{F(x_3)\}
$$

下一步还合并了包含$F(x_1)$和$F(x_3)$的类，因为$x_1$和$x_3$在同一个类中：
$$
\{x_1, x_2, x_3\}, \{x_4, x_5\}, \{F(x_1), F(x_3)\}
$$

在步骤2中，我们注意到$\varphi^{UF}$中包含谓词$F(x_1) \neq F(x_3)$，但$F(x_1)$和$F(x_3)$在同一个类中。因此，$\varphi^{UF}$是不可满足的。

算法4.3.1的变体可以通过并查集数据结构高效实现，时间复杂度为$O(n \log n)$ 。

我们的最终目标是解决具有任意布尔结构的公式的通用情况。在其方法的最初展示中，Shostak通过分案例实现了对析取的支持，这成为该方法的瓶颈。例如，给定公式
$$
\varphi^{UF} := x_1 = x_2 \lor (x_2 = x_3 \land x_4 = x_5 \land x_5 \neq x_1 \land F(x_1) \neq F(x_3))
$$
他分别考虑了析取左侧和右侧的两个情况。这在需要考虑的情况不多时效果很好。

如何处理命题结构的通用问题在本书研究的所有理论中都会出现。有两种主要的方法。正如第3章讨论的那样，一种高效的方法是将基于DPLL的SAT求解器与用于决定特定理论的文字合取的算法结合起来。前者搜索公式命题部分的满足赋值，后者用于检查特定命题赋值是否对应于等式谓词的满足赋值。

另一种方法是基于公式到命题逻辑的完全归约，这是第11章的主题。

## 4.4 函数一致性是不够的

函数一致性并不总是足以证明正确的陈述。这并不令人惊讶，因为用无解释函数替换具体的解释函数显然会丢失信息。以加法函数“+”为例。假设我们有一个包含两个函数实例$x_1 + y_1$和$x_2 + y_2$的公式，并且由于公式的其他部分，满足$x_1 = y_2$和$y_1 = x_2$。进一步，假设我们用一个二元无解释函数$F$替换“+”。由于我们只比较参数对在出现的顺序中的顺序，证明无法依赖这两个函数实例的计算结果相同。换句话说，仅靠函数一致性无法捕捉“+”函数的交换性，这可能是证明所必需的。这表明，使用无解释函数会丧失完备性（见定义1.6）。

我们可以添加约束来捕捉更多关于原始函数的信息——例如上例中的交换性。对于上述例子，我们可以添加以下约束：
$$
(x_1 = y_2 \land x_2 = y_1) \Rightarrow F(x_1, x_2) = F(y_1, y_2)
$$

这些约束可以根据需要进行调整，以反映无解释函数的属性。换句话说，通过添加这些约束，我们使它们成为部分解释函数，因为我们对其属性进行了建模。例如，对于乘法函数，我们可以添加一个约束：如果一个参数等于0，则结果也为0。**通常，公式越抽象，计算上越容易解决。另一方面，公式越抽象，关于其原始版本的正确事实就越少**。通过试错过程可以找到适合给定公式的正确抽象级别。这样的过程甚至可以通过抽象-细化循环自动化，如算法4.4.1所示（这不太像算法，而更像是需要根据具体问题进行具体化的框架）。在步骤2中，如果抽象公式有效，算法返回“有效”。此步骤的正确性由(4.3)隐含。如果公式无效且抽象公式$\phi'$与原始公式相同，算法在下一步返回“无效”。接下来的可选步骤（步骤4）对于算法的正确性不是必要的，但仅对其性能有影响。只有在这个步骤比解决$\phi$本身更容易时才值得执行。

在实现这样的算法时，有很多创作空间：在步骤5中添加哪些约束？什么时候采用原始解释函数？如何实现步骤4？在第6.3节中描述了这样一种用于位向量算术的程序实例。

![image.png|599](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240518145355.png)
