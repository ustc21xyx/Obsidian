
# 命题逻辑的决策程序


## CDCL 算法
### Decision Heuristics 决策启发式

SAT 求解中最重要的因素可能就是选择变量和变量值的策略。这种策略被称为 SAT 求解器的==决策启发式==。
下面介绍一些重要的决策启发式：

#### Jeroslow-Wang
$给定一个CNF公式\mathcal{B}，对于每个\mathcal{l}计算$
$$\begin{aligned}J(l)&=\Sigma_{\omega\in\mathcal{B},l\in\omega}2^{-|\omega|},\end{aligned}$$
$其中\omega 代表一个子句，|\omega|是它的长度，选择使得|mathcal{J}(\mathcal{l})最大的\mathcal{l}，并且\mathcal{l}和\neg \mathcal{l}都没有被断言$
这个启发式会给频繁出现在短子句的字面量(literals)更高的优先级。它可以是静态的，也可以是动态的。动态的只考虑未被满足的子句。动态的启发式拥有更好的决策，但每次的决策也会有更大的开销。

#### Dynamic Largest Individual Sum(DLIS)
在每一个决策层，在所有未被赋值的字面量中，选择可以满足最多数量的未被满足的子句的字面量。
想要实现这样的一个启发式，最常见的做法是：对于每个字面量，维护一个指针，指向一个维护所有它出现的子句的列表（类似倒排索引）。
这个策略有巨大的开销，因为单次决策的复杂度与子句数量呈线性关系。
这个策略的另一个变体是：计算由这次决策，通过BCP可以满足的子句数量。这个策略拥有更好的决策，但也拥有更大的开销。

#### Variable State Independent Decaying Sum(VSIDS) and Variants
这是 SAT 求解器 Chaff \[202\] 中引入的一种策略，它让人想起 DLIS，但效率要高得多。首先，在计算每个字面出现的子句数量时，忽略该子句是否已经满足的问题。这意味着对每次决策质量的估算都会受到影响，但决策的复杂性会更好：假设我们将字面意思按分数排序保存在一个列表中，那么决策所需的时间是不变的。其次，定期将所有分数除以2。
这个策略的目的是使得决策启发式是**冲突驱动(Conflict-driven)**,这意味着它要优先解决最新被发现的冲突。为了达到这个目标，我们需要给予那些出现在最新冲突的变量更高的分数。
回想一下，每次冲突都会产生一个冲突子句。一个新的冲突子句和其他子句一样，会给其中出现的每个字面的分值加 1。自添加该冲突子句以来，时间过得越久，这些字面的得分被除以 2 的次数就越多。引入了 VSIDS 的 SAT 求解器 Chaff 可以通过控制分数被除的频率和除以分数的常数来调整这一策略。事实证明，不同的 CNF 公式族使用不同的参数求解效果最佳。

还有其他冲突驱动的启发式。例如，MiniSAT采用的策略。
MiniSAT为每一个变量维护一个活动分值，用来衡量每个变量在推断新子句时的参与程度。如果一个子句c是由子句$c_1,...,c_n$推断出来的，那么子句$c_1,...,c_n$中的每一个v的实例a，都会使得v增加一个inc。inc的大小在每一次冲突后都会乘以1.05，因此罪域最近冲突的变量得分最高。
为了防止溢出，如果某个变量的活动得分超过$10^{100}$，则将所有变量的得分以及inc乘以$10^{-100}$。得分最高的变量被选中，为该变量选择的值要么是假值，要么是随机值，要么是该变量之前的赋值。

在MiniSAT冲突驱动的求解器中，并没有试图猜测变量的正确值（即它是为每个变量维护活动分数，而不是针对字面维护分数），这一事实表明，重要的是搜索的局部性和学习，而不是对分支的正确猜测。这并不奇怪：即使在可满足公式中，大多数的分支也不会导致满足赋值

#### Clause-Based Heuristics
在这一类启发式中，在最近冲突子句中出现的字面量会被赋予绝对优先级。
针对每一个变量，使用类似VSIDS的方式维护一个分数（出现加一，定期除以2）。再针对每一个字面量，也维护一个分数，但**不**定期除以2。
将所有的冲突子句放入一个栈中。每当一个决策完成时，找到栈中未被解决的子句中最靠近栈顶的。从这个子句中选择分数最高的变量，赋予分数更高的字面量对应的值。当栈为空时，策略不变，改为从所有未被赋值的变量选择分值最高的变量。
这种启发式最早是在一个名为 Berkmin 的 SAT 求解器中实现的。其原理是给予最近冲突中出现的变量绝对优先权，根据经验，这似乎更有效。与 VSIDS 不同的是，它只关注未解决的冲突。
一种不同的基于子句的策略称为Clause-Move-To-Front（CMTF）。它与Berkmin相似，不同之处在于，在学习新子句时，参与解决新子句的k个子句（k是一个可调常数）被推到列表的末尾，紧接在新子句之前。这一策略的理由是它保持了搜索的集中性。例如，假设一个子句c是从c1、c2和c3中解析出来的。我们可以写作$c1 ∧ c2 ∧ c3 ⇒ c$，这表明满足c比满足$c1 ∧ c2 ∧ c3$更容易。因此，当当前部分赋值导致$c1 ∧ c2 ∧ c3$矛盾时，求解器回溯，并在返回这些子句之前尝试满足一个更容易的公式，即c。CMTF在称为HaifaSat的SAT求解器中实现，另一种称为Clause-Based Heuristic（CBH）的变体在Eureka中实现

### Resolution图和不可满足核心

**Definition 2.13 二元解析图(binary resolution graph)**：二元解析图是一个有向无环图，其中每个节点都标有一个子句，每个根节点都对应一个原始子句，每个非根节点都有恰好两条进入边，并对应一个通过二元解析从其父节点在图中派生出来的子句。

**Deﬁnition 2.14 超解析图(hyper-resolution graph)：** 超解析图是一个有向无环图，其中每个节点都标有一个子句，每个根节点都对应一个原始子句，每个非根节点都有两条或两条以上的输入边，并对应一个通过二进制解析从图中其父节点派生出来的子句，也可能是通过图中未表示的其他子句派生出来的子句。
![image.png](https://raw.githubusercontent.com/ustc21xyx/picture-bed/main/20240515181335.png)
在不可满足公式的情况下，解析图有一个汇节点（即只有输入边的节点），它对应于一个空子句。

解析图可以帮助我们推导一个不可满足公式的不可满足核心
**Definition 2.16 不可满足核心(unsatisfiable core)**：一个不可满足的CNF公式的**不可满足核心**：该CNF初始子句集合中的任意不可满足的子句子集。
一个CNF的不可满足核心，在我们研究问题时可能很有用，因为它可以满足我们集中关注不可满足的原因。

解析图的另一个常见用途是证明 SAT 求解器得出的公式不可满足的结论。与可满足实例的情况不同，可满足赋值是一个易于检查的证据，而检查不可满足结果则比较困难。然而，利用解析图，独立检查程序可以从原始子句开始重放解析步骤，直到得出空子句为止。这种验证所需的时间与解析证明的大小成线性关系。

### 递增满意度
在许多工业应用中，SAT 求解器都是更大系统中的一个组件，系统会向其发送满足性查询。例如，一个为机器人规划路径的程序可能会使用 SAT 求解器来查找是否存在距离当前状态 k 步以内的路径。如果答案是否定的，程序就会增加 k 步并再次尝试。这里重要的一点是，要求 SAT 求解器求解的公式序列并不是任意的：这些公式有很多共同点。我们能否利用这一事实让 SAT 求解器运行得更快？我们应该以某种方式重复使用以前收集的信息，以加快当前实例的求解速度。为了让事情更简单，请考虑两个连续求解的 CNF 公式 $C_{1}$和$C_2$，并假设在求解 $C_1$ 时已知 $C_2$。下面是求解$C_2$ 时可以重复使用的两种信息：
- **重复使用子句。** 我们应该回答下面的问题：如果 c 是在求解 $C_1$ 时学到的冲突子句，那么在什么条件下 $C_2$ 和 $C_2 ∧ c$ 是等价的？如果我们把 $C_1$ 和 $C_2$ 看作是子句的集合，就更容易回答这个问题了。让 $C$ 表示交集 $C 1 ∩ C 2$ 中的子句。在求解 $C_2$ 时，可以重复使用仅从 $C$ 子句集中学习到的任何子句。在实践中，如上述路径规划问题，序列中的连续公式非常相似，因此 $C_1$ 和 $C_2$ 共享其绝大部分子句，这意味着所学到的大部分内容都可以重复使用。
- **重复使用启发式参数**。在求解过程中会更新各种权重，用于启发式地指导搜索，例如，变量分数用于决策 ，权重表示子句在推导新子句时的活跃程度，用于确定哪些已学子句应保留，哪些应删除，等等。如果 $C_1$和 $C_2$ 足够相似，那么使用 $C_1$ 求解过程结束时的权重开始求解 $C_2$ 可以加快 $C_2$ 的求解。

Assumptions在现代SAT（可满足性）求解器中扮演重要角色，特别是在递增SAT求解过程中。它们是已知在求解特定问题（如 $C_1$） 时成立的文字，但在求解后续问题（如 $C_2$） 时可能被移除或取反。

假设（Assumptions）的机制是由MiniSAT求解器引入的。具体来说，假设是一组特定的文字，这些文字被传递给求解器作为参数。求解器将假设视为特殊的文字，并根据这些假设进行初始决策。如果求解器回溯到最后一个假设决策级别以下，它将声明公式不可满足，因为在不改变假设的情况下没有解决方案。

假设机制的关键点包括以下几个方面：

1. **初始决策**：假设文字决定了求解器的初始一组决策。例如，如果假设文字是 $a_1, a_2, \ldots, a_n$，那么求解器将开始做出 $a_1=true, a_2=true, \ldots, a_n=true$ 的决策，并按通常方式应用布尔约束传播（BCP）。如果在某一点求解器回溯到决策级别 $n$ 或以下，它将声明公式不可满足。
2. **学习子句重用**：所有学习到的子句都是独立于假设的，因此在假设不再成立时仍可以重用这些子句。这意味着可以在求解 $C_2$ 时保持在求解 $C_1$ 过程中学习到的所有子句，从而节省重新解析公式的时间。
3. **假设的添加和删除**：为了解决递增SAT问题，假设机制还允许在实例之间添加和删除子句。当需要添加子句时，求解器接收应添加的子句集（例如，$C_2 \setminus C_1$）。当需要删除子句时，可以通过向每个要删除的子句添加一个新的假设文字（对应于一个新变量）并取反来实现。例如，如果 $c = (x_1 \lor x_2)$，那么它可以被替换为 $c' = (\neg a \lor x_1 \lor x_2)$，其中 $a$ 是一个新变量。在假设 $a=true$ 的情况下，$c$ 与 $c'$ 等价，从而不会改变公式的可满足性。在求解 $C_2$ 时，将该假设替换为 $a=false$，相当于删除子句 $c$。以这种方式使用的假设文字被称为子句选择器。

假设机制通过上述方式提高了递增SAT求解器的效率，使其能够更快速地解决一系列相关联的SAT问题。这种机制在实际应用中非常有用，特别是在需要频繁处理相似公式的场景中，例如路径规划、调度和验证等领域。