---
cssclasses:
  - img-grid
---

From Wikipedia, the free encyclopedia


**Computation tree logic** (**CTL**) is a branching-time [logic](https://en.wikipedia.org/wiki/Mathematical_logic "Mathematical logic"), meaning that its model of [time](https://en.wikipedia.org/wiki/Time "Time") is a [tree-like](https://en.wikipedia.org/wiki/Tree_(graph_theory) "Tree (graph theory)") structure in which the future is not determined; there are different paths in the future, any one of which might be an actual path that is realized. It is used in [formal verification](https://en.wikipedia.org/wiki/Formal_verification "Formal verification") of software or hardware artifacts, typically by software applications known as [model checkers](https://en.wikipedia.org/wiki/Model_checker "Model checker"), which determine if a given artifact possesses [safety or liveness properties](https://en.wikipedia.org/wiki/Safety_and_Liveness_Properties "Safety and Liveness Properties"). For example, CTL can specify that when some initial condition is satisfied (e.g., all program variables are positive or no cars on a highway straddle two lanes), then all possible executions of a program avoid some undesirable condition (e.g., dividing a number by zero or two cars colliding on a highway). In this example, the safety property could be verified by a model checker that explores all possible transitions out of program states satisfying the initial condition and ensures that all such executions satisfy the property. Computation tree logic belongs to a class of [temporal logics](https://en.wikipedia.org/wiki/Temporal_logic "Temporal logic") that includes [linear temporal logic](https://en.wikipedia.org/wiki/Linear_temporal_logic "Linear temporal logic") (LTL). Although there are properties expressible only in CTL and properties expressible only in LTL, all properties expressible in either logic can also be expressed in [CTL\*](https://en.wikipedia.org/wiki/CTL* "CTL*").

## History\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=1 "Edit section: History")\]

CTL was first proposed by [Edmund M. Clarke](https://en.wikipedia.org/wiki/Edmund_M._Clarke "Edmund M. Clarke") and [E. Allen Emerson](https://en.wikipedia.org/wiki/E._Allen_Emerson "E. Allen Emerson") in 1981, who used it to synthesize so-called _synchronisation skeletons_, _i.e_ abstractions of [concurrent programs](https://en.wikipedia.org/wiki/Concurrent_program "Concurrent program").

Since the introduction of CTL, there has been debate about the relative merits of CTL and LTL. Because it is more computationally efficient to model check, CTL has become more common in industrial use, and many of the most successful model-checking tools use CTL as a specification language.<sup id="cite_ref-1" data-immersive-translate-walked="c317c7b1-9b40-4568-8bd6-5a7ab668b6f8"><a href="https://en.wikipedia.org/wiki/Computation_tree_logic#cite_note-1">[1]</a></sup>

## Syntax of CTL\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=2 "Edit section: Syntax of CTL")\]

The [language](https://en.wikipedia.org/wiki/Regular_Language "Regular Language") of [well-formed formulas](https://en.wikipedia.org/wiki/Well-formed_formula "Well-formed formula") for CTL is generated by the following [grammar](https://en.wikipedia.org/wiki/Context-free_grammar "Context-free grammar"):

![{\displaystyle {\begin{aligned}\phi &::=\bot \mid \top \mid p\mid (\neg \phi )\mid (\phi \land \phi )\mid (\phi \lor \phi )\mid (\phi \Rightarrow \phi )\mid (\phi \Leftrightarrow \phi )\\&\mid \quad {\mbox{AX }}\phi \mid {\mbox{EX }}\phi \mid {\mbox{AF }}\phi \mid {\mbox{EF }}\phi \mid {\mbox{AG }}\phi \mid {\mbox{EG }}\phi \mid {\mbox{A }}[\phi {\mbox{ U }}\phi ]\mid {\mbox{E }}[\phi {\mbox{ U }}\phi ]\end{aligned}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/534ec347982ee3cda15039732fb05aa9e3ebc7bf)

where ![{\displaystyle p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/81eac1e205430d1f40810df36a0edffdc367af36) ranges over a set of [atomic formulas](https://en.wikipedia.org/wiki/Atomic_formula "Atomic formula"). It is not necessary to use all connectives – for example, ![{\displaystyle \{\neg ,\land ,{\mbox{AX}},{\mbox{AU}},{\mbox{EU}}\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/6ce47e80e79ce95a03e45a473446e21b39c5657b) comprises a complete set of connectives, and the others can be defined using them.

For example, the following is a well-formed CTL formula:

![{\displaystyle {\mbox{EF }}({\mbox{EG }}p\Rightarrow {\mbox{AF }}r)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/66e56d70e1dec97b2e179d973f231faae4060a8f)

The following is not a well-formed CTL formula:

![{\displaystyle {\mbox{EF }}{\big (}r{\mbox{ U }}q{\big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/60410d0de68554a35819ca1cf29626d8d46498da)

The problem with this string is that ![{\displaystyle \mathrm {U} }](https://wikimedia.org/api/rest_v1/media/math/render/svg/b2ad0ddf5dc86cfc99e6ffdb37f3f0329f0982b0) can occur only when paired with an ![{\displaystyle \mathrm {A} }](https://wikimedia.org/api/rest_v1/media/math/render/svg/ff6366939c4ebbd4e8494d0dedc54c4b8dd7135a) or an ![{\displaystyle \mathrm {E} }](https://wikimedia.org/api/rest_v1/media/math/render/svg/be1811407dea8b43727d28dbe8da7251985b03e8)
CTL uses [atomic propositions](https://en.wikipedia.org/wiki/First-order_logic#Vocabulary "First-order logic") as its building blocks to make statements about the states of a system. These propositions are then combined into formulas using [logical operators](https://en.wikipedia.org/wiki/Logical_operator "Logical operator") and [temporal operators](https://en.wikipedia.org/wiki/Temporal_logic "Temporal logic").

## Operators\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=3 "Edit section: Operators")\]

### Logical operators\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=4 "Edit section: Logical operators")\]

The [logical operators](https://en.wikipedia.org/wiki/Logical_connective "Logical connective") are the usual ones: ¬, ∨, ∧, ⇒ and ⇔. Along with these operators CTL formulas can also make use of the boolean constants [true](https://en.wikipedia.org/wiki/Truth "Truth") and [false](https://en.wikipedia.org/wiki/False_(logic) "False (logic)").

### Temporal operators\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=5 "Edit section: Temporal operators")\]

The temporal operators are the following:

-   Quantifiers over paths
    -   **A** Φ – **A**ll: Φ has to hold on all paths starting from the current state.
    -   **E** Φ – **E**xists: there exists at least one path starting from the current state where Φ holds.
-   Path-specific quantifiers
    -   **X** _φ_ – Ne**x**t: _φ_ has to hold at the next state (this operator is sometimes noted **N** instead of **X**).
    -   **G** _φ_ – **G**lobally: _φ_ has to hold on the entire subsequent path.
    -   **F** _φ_ – **F**inally: _φ_ eventually has to hold (somewhere on the subsequent path).
    -   _φ_ **U** _ψ_ – **U**ntil: _φ_ has to hold _at least_ until at some position _ψ_ holds. This implies that _ψ_ will be verified in the future.
    -   _φ_ **W** _ψ_ – **W**eak until: _φ_ has to hold until _ψ_ holds. The difference with **U** is that there is no guarantee that _ψ_ will ever be verified. The **W** operator is sometimes called "unless".

In [CTL\*](https://en.wikipedia.org/wiki/CTL* "CTL*"), the temporal operators can be freely mixed. In CTL, operators must always be grouped in pairs: one path operator followed by a state operator. See the examples below. [CTL\*](https://en.wikipedia.org/wiki/CTL* "CTL*") is strictly more expressive than CTL.

### Minimal set of operators\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=6 "Edit section: Minimal set of operators")\]

In CTL there are minimal sets of operators. All CTL formulas can be transformed to use only those operators. This is useful in [model checking](https://en.wikipedia.org/wiki/Model_checking "Model checking"). One minimal set of operators is: {true, ∨, ¬, **EG**, **EU**, **EX**}.

Some of the transformations used for temporal operators are:

-   **EF**_φ_ == **E**\[true**U**(_φ_)\] ( because **F**_φ_ == \[true**U**(_φ_)\] )
-   **AX**_φ_ == ¬**EX**(¬_φ_)
-   **AG**_φ_ == ¬**EF**(¬_φ_) == ¬ **E**\[true**U**(¬_φ_)\]
-   **AF**_φ_ == **A**\[true**U**_φ_\] == ¬**EG**(¬_φ_)
-   **A**\[_φ_**U**_ψ_\] == ¬( **E**\[(¬_ψ_)**U**¬(_φ_∨_ψ_)\] ∨ **EG**(¬_ψ_) )

## Semantics of CTL\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=7 "Edit section: Semantics of CTL")\]

### Definition\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=8 "Edit section: Definition")\]

CTL formulae are interpreted over [transition systems](https://en.wikipedia.org/wiki/Transition_system "Transition system"). A transition system is a triple ![{\displaystyle {\mathcal {M}}=(S,{\rightarrow },L)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/40a7b2629e5a1b0764ddaedd1c303c6a907c9a45), where ![{\displaystyle S}](https://wikimedia.org/api/rest_v1/media/math/render/svg/4611d85173cd3b508e67077d4a1252c9c05abca2) is a set of states, ![{\displaystyle {\rightarrow }\subseteq S\times S}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1dea57cc7257730f5787c2ff9335376e420c0c54) is a transition relation, assumed to be serial, i.e. every state has at least one successor, and ![{\displaystyle L}](https://wikimedia.org/api/rest_v1/media/math/render/svg/103168b86f781fe6e9a4a87b8ea1cebe0ad4ede8) is a labelling function, assigning propositional letters to states. Let ![{\displaystyle {\mathcal {M}}=(S,\rightarrow ,L)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/61149a3f0713302d68a0847aa068b2d690ad7a83) be such a transition model, with ![{\displaystyle s\in S}](https://wikimedia.org/api/rest_v1/media/math/render/svg/acce52dffd84d073a24f4606a175da60148fd0c6), and ![{\displaystyle \phi \in F}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b4b6fbd3e2c4a48276aaa91e7e1743fbf11156c9), where ![{\displaystyle F}](https://wikimedia.org/api/rest_v1/media/math/render/svg/545fd099af8541605f7ee55f08225526be88ce57) is the set of [well-formed formulas](https://en.wikipedia.org/wiki/Well-formed_formula "Well-formed formula") over the [language](https://en.wikipedia.org/wiki/Formal_language "Formal language") of ![{\displaystyle {\mathcal {M}}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2cc2abebd45ec020509a0ec548b67c9a2cb7cecd).

Then the relation of semantic [entailment](https://en.wikipedia.org/wiki/Entailment "Entailment") ![{\displaystyle ({\mathcal {M}},s\models \phi )}](https://wikimedia.org/api/rest_v1/media/math/render/svg/70925759561d826a66137c5130c40ed8c21b5d1b) is defined recursively on ![{\displaystyle \phi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4):

1.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models \top {\Big )}\land {\Big (}({\mathcal {M}},s)\not \models \bot {\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/33f267a82d4b3171584ebc4223c8dcf4dda9dc6f)
2.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models p{\Big )}\Leftrightarrow {\Big (}p\in L(s){\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3a05f2e40a319619c299b98b816d4e41b6e89e77)
3.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models \neg \phi {\Big )}\Leftrightarrow {\Big (}({\mathcal {M}},s)\not \models \phi {\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d9bf165c6200589eaa928c919b0a4ef136446be9)
4.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models \phi _{1}\land \phi _{2}{\Big )}\Leftrightarrow {\Big (}{\big (}({\mathcal {M}},s)\models \phi _{1}{\big )}\land {\big (}({\mathcal {M}},s)\models \phi _{2}{\big )}{\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/49a632344275698cb913d1952d0fa7314106f319)
5.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models \phi _{1}\lor \phi _{2}{\Big )}\Leftrightarrow {\Big (}{\big (}({\mathcal {M}},s)\models \phi _{1}{\big )}\lor {\big (}({\mathcal {M}},s)\models \phi _{2}{\big )}{\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/297daf314bded9e1bd8aa70f52125239147b3208)
6.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models \phi _{1}\Rightarrow \phi _{2}{\Big )}\Leftrightarrow {\Big (}{\big (}({\mathcal {M}},s)\not \models \phi _{1}{\big )}\lor {\big (}({\mathcal {M}},s)\models \phi _{2}{\big )}{\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9f32b0b8faa4b9737f0443773e54673a5b394348)
7.  ![{\displaystyle {\bigg (}({\mathcal {M}},s)\models \phi _{1}\Leftrightarrow \phi _{2}{\bigg )}\Leftrightarrow {\bigg (}{\Big (}{\big (}({\mathcal {M}},s)\models \phi _{1}{\big )}\land {\big (}({\mathcal {M}},s)\models \phi _{2}{\big )}{\Big )}\lor {\Big (}\neg {\big (}({\mathcal {M}},s)\models \phi _{1}{\big )}\land \neg {\big (}({\mathcal {M}},s)\models \phi _{2}{\big )}{\Big )}{\bigg )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a7967db0b63692f7fa32ab04fea295d3117b967e)
8.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models AX\phi {\Big )}\Leftrightarrow {\Big (}\forall \langle s\rightarrow s_{1}\rangle {\big (}({\mathcal {M}},s_{1})\models \phi {\big )}{\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/b3c039594592d6766cdf664ae23229f2822e049e)
9.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models EX\phi {\Big )}\Leftrightarrow {\Big (}\exists \langle s\rightarrow s_{1}\rangle {\big (}({\mathcal {M}},s_{1})\models \phi {\big )}{\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/2ffa515f4d36691664ef1148c1c1ac3fcd8367d2)
10.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models AG\phi {\Big )}\Leftrightarrow {\Big (}\forall \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\forall i{\big (}({\mathcal {M}},s_{i})\models \phi {\big )}{\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8ffdff10ab7d1509889225841a053d6e64ab8f4b)
11.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models EG\phi {\Big )}\Leftrightarrow {\Big (}\exists \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\forall i{\big (}({\mathcal {M}},s_{i})\models \phi {\big )}{\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/5c073f861d459fd9cf0304e1fcc26b01fa1f7619)
12.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models AF\phi {\Big )}\Leftrightarrow {\Big (}\forall \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\exists i{\big (}({\mathcal {M}},s_{i})\models \phi {\big )}{\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/332acc1e3685a7e38a1ba5798babf5dd1edf6746)
13.  ![{\displaystyle {\Big (}({\mathcal {M}},s)\models EF\phi {\Big )}\Leftrightarrow {\Big (}\exists \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\exists i{\big (}({\mathcal {M}},s_{i})\models \phi {\big )}{\Big )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/93838e53fe87922a77b2f669d8fb4466ff63beda)
14.  ![{\displaystyle {\bigg (}({\mathcal {M}},s)\models A[\phi _{1}U\phi _{2}]{\bigg )}\Leftrightarrow {\bigg (}\forall \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\exists i{\Big (}{\big (}({\mathcal {M}},s_{i})\models \phi _{2}{\big )}\land {\big (}\forall (j<i)({\mathcal {M}},s_{j})\models \phi _{1}{\big )}{\Big )}{\bigg )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3dcde0c80e048ab8a9f89e4d75f5c94aea75a6f3)
15.  ![{\displaystyle {\bigg (}({\mathcal {M}},s)\models E[\phi _{1}U\phi _{2}]{\bigg )}\Leftrightarrow {\bigg (}\exists \langle s_{1}\rightarrow s_{2}\rightarrow \ldots \rangle (s=s_{1})\exists i{\Big (}{\big (}({\mathcal {M}},s_{i})\models \phi _{2}{\big )}\land {\big (}\forall (j<i)({\mathcal {M}},s_{j})\models \phi _{1}{\big )}{\Big )}{\bigg )}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0d04777cb8e0ba5d53918b4b64927615b6fefc1a)

### Characterisation of CTL\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=9 "Edit section: Characterisation of CTL")\]

Rules 10–15 above refer to computation paths in models and are what ultimately characterise the "Computation Tree"; they are assertions about the nature of the infinitely deep computation tree rooted at the given state ![{\displaystyle s}](https://wikimedia.org/api/rest_v1/media/math/render/svg/01d131dfd7673938b947072a13a9744fe997e632).

### Semantic equivalences\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=10 "Edit section: Semantic equivalences")\]

The formulae ![{\displaystyle \phi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/72b1f30316670aee6270a28334bdf4f5072cdde4) and ![{\displaystyle \psi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/45e5789e5d9c8f7c79744f43ecaaf8ba42a8553a) are said to be semantically equivalent if any state in any model that satisfies one also satisfies the other. This is denoted ![{\displaystyle \phi \equiv \psi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/6786212cdc76b6ec6fe76bae5c2facaa1874f70b)

It can be seen that ![{\displaystyle \mathrm {A} }](https://wikimedia.org/api/rest_v1/media/math/render/svg/ff6366939c4ebbd4e8494d0dedc54c4b8dd7135a) and ![{\displaystyle \mathrm {E} }](https://wikimedia.org/api/rest_v1/media/math/render/svg/be1811407dea8b43727d28dbe8da7251985b03e8) are duals, being universal and existential computation path quantifiers respectively: ![{\displaystyle \neg \mathrm {A} \Phi \equiv \mathrm {E} \neg \Phi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/9d38ef97b62d29351fe6c432760a42b5dd170d18).

Furthermore, so are ![{\displaystyle \mathrm {G} }](https://wikimedia.org/api/rest_v1/media/math/render/svg/d895cb984f1cafde4d7c7f4993e6b92d72b6ad15) and ![{\displaystyle \mathrm {F} }](https://wikimedia.org/api/rest_v1/media/math/render/svg/fd88ce01cebb719c991531bf9a76dacc204f6d1a).

Hence an instance of [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws "De Morgan's laws") can be formulated in CTL:

![{\displaystyle \neg AF\phi \equiv EG\neg \phi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/18e2f03724a1739d0c69b4bb75f080ba1424c65b)

![{\displaystyle \neg EF\phi \equiv AG\neg \phi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/25b3864276c430af2973d13420c63562972fa5a1)

![{\displaystyle \neg AX\phi \equiv EX\neg \phi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/778b6bd72e8747e61b47b3d7ed256376a6c77b30)

It can be shown using such identities that a subset of the CTL temporal connectives is adequate if it contains ![{\displaystyle EU}](https://wikimedia.org/api/rest_v1/media/math/render/svg/0540f98b65a648c9f2711f2712b36120ae3b910d), at least one of ![{\displaystyle \{AX,EX\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/90780c46e83b9620f0b74e98798daa238d940876) and at least one of ![{\displaystyle \{EG,AF,AU\}}](https://wikimedia.org/api/rest_v1/media/math/render/svg/8f200e4eeec0c6ec39860e01cc92f6ef61d2d7db) and the boolean connectives.

The important equivalences below are called the **expansion laws**; they allow unfolding the verification of a CTL connective towards its successors in time.

![{\displaystyle AG\phi \equiv \phi \land AXAG\phi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/f0364fe35455e99a8b8921b6e2b662ed69ce731e)

![{\displaystyle EG\phi \equiv \phi \land EXEG\phi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/3f8a3c8d890e863d14685d05b2c47e1ff2ceb01a)

![{\displaystyle AF\phi \equiv \phi \lor AXAF\phi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/ac867ff99f6db222225dd052ab3979c819036419)

![{\displaystyle EF\phi \equiv \phi \lor EXEF\phi }](https://wikimedia.org/api/rest_v1/media/math/render/svg/83c1396dd5043b477b86fcbef6a1e6936213e14f)

![{\displaystyle A[\phi U\psi ]\equiv \psi \lor (\phi \land AXA[\phi U\psi ])}](https://wikimedia.org/api/rest_v1/media/math/render/svg/04e432a4e05e0f27a955be8f1520f6746e653517)

![{\displaystyle E[\phi U\psi ]\equiv \psi \lor (\phi \land EXE[\phi U\psi ])}](https://wikimedia.org/api/rest_v1/media/math/render/svg/1e5839bd0d5c32f192612cb8ed45733343e15442)

## Examples\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=11 "Edit section: Examples")\]

Let "P" mean "I like chocolate" and Q mean "It's warm outside."

-   **AG**.P

"I will like chocolate from now on, no matter what happens."

-   **EF**.P

"It's possible I may like chocolate some day, at least for one day."

-   **AF**.**EG**.P

"It's always possible (AF) that I will suddenly start liking chocolate for the rest of time." (Note: not just the rest of my life, since my life is finite, while **G** is infinite).

-   **EG**.**AF**.P

"Depending on what happens in the future (E), it's possible that for the rest of time (G), I'll be guaranteed at least one (AF) chocolate-liking day still ahead of me. However, if something ever goes wrong, then all bets are off and there's no guarantee about whether I'll ever like chocolate."

The two following examples show the difference between CTL and CTL\*, as they allow for the until operator to not be qualified with any path operator (**A** or **E**):

-   **AG**(P**U**Q)

"From now until it's warm outside, I will like chocolate every single day. Once it's warm outside, all bets are off as to whether I'll like chocolate anymore. Oh, and it's guaranteed to be warm outside eventually, even if only for a single day."

-   **EF**((**EX**.P)**U**(**AG**.Q))

"It's possible that: there will eventually come a time when it will be warm forever (AG.Q) and that before that time there will always be _some_ way to get me to like chocolate the next day (EX.P)."

## Relations with other logics\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=12 "Edit section: Relations with other logics")\]

Computation tree logic (CTL) is a subset of CTL\* as well as of the [modal μ calculus](https://en.wikipedia.org/wiki/Modal_mu_calculus "Modal mu calculus"). CTL is also a fragment of Alur, Henzinger and Kupferman's [alternating-time temporal logic](https://en.wikipedia.org/wiki/Alternating-time_temporal_logic "Alternating-time temporal logic") (ATL).

Computation tree logic (CTL) and [linear temporal logic](https://en.wikipedia.org/wiki/Linear_temporal_logic "Linear temporal logic") (LTL) are both a subset of CTL\*. CTL and [LTL](https://en.wikipedia.org/wiki/Linear_temporal_logic "Linear temporal logic") are not equivalent and they have a common subset, which is a proper subset of both CTL and LTL.

-   **FG**.P exists in LTL but not in CTL.
-   **AG**(P⇒((**EX**.Q)∧(**EX**¬Q))) and **AG.EF**.P exist in CTL but not in LTL.

## Extensions\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=13 "Edit section: Extensions")\]

CTL has been extended with [second-order](https://en.wikipedia.org/wiki/Second-order_logic "Second-order logic") quantification ![{\displaystyle \exists p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/3b2b8b0cd274f80eeade7b0c40438a5758bcafd7) and ![{\displaystyle \forall p}](https://wikimedia.org/api/rest_v1/media/math/render/svg/d0d457f5c70d5f2f1abbe20ba1903ab554916bd6) to _quantified computational tree logic_ (QCTL).<sup id="cite_ref-2" data-immersive-translate-walked="c317c7b1-9b40-4568-8bd6-5a7ab668b6f8"><a href="https://en.wikipedia.org/wiki/Computation_tree_logic#cite_note-2">[2]</a></sup> There are two semantics:

-   the tree semantics. We label nodes of the computation tree. QCTL\* = QCTL = [MSO](https://en.wikipedia.org/wiki/Monadic_second-order_logic "Monadic second-order logic") over trees. Model checking and satisfiability are tower complete.
-   the structure semantics. We label states. QCTL\* = QCTL = MSO over [graphs](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics) "Graph (discrete mathematics)"). Model checking is [PSPACE-complete](https://en.wikipedia.org/wiki/PSPACE-complete "PSPACE-complete") but satisfiability is [undecidable](https://en.wikipedia.org/wiki/Undecidable_problem "Undecidable problem").

A reduction from the model-checking problem of QCTL with the structure semantics, to TQBF (true quantified Boolean formulae) has been proposed, in order to take advantage of the QBF solvers.<sup id="cite_ref-3" data-immersive-translate-walked="c317c7b1-9b40-4568-8bd6-5a7ab668b6f8"><a href="https://en.wikipedia.org/wiki/Computation_tree_logic#cite_note-3">[3]</a></sup>

## See also\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=14 "Edit section: See also")\]

-   [Probabilistic CTL](https://en.wikipedia.org/wiki/Probabilistic_CTL "Probabilistic CTL")
-   [Fair computational tree logic](https://en.wikipedia.org/wiki/Fair_computational_tree_logic "Fair computational tree logic")
-   [Linear temporal logic](https://en.wikipedia.org/wiki/Linear_temporal_logic "Linear temporal logic")

## References\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=15 "Edit section: References")\]

1.  **[^](https://en.wikipedia.org/wiki/Computation_tree_logic#cite_ref-1 "Jump up")** Vardi, Moshe Y. (2001). ["Branching vs. Linear Time: Final Showdown"](https://link.springer.com/content/pdf/10.1007/3-540-45319-9_1.pdf) (PDF). _Tools and Algorithms for the Construction and Analysis of Systems_. Lecture Notes in Computer Science. **2031**. Springer, Berlin: 1–22. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1007/3-540-45319-9\_1](https://doi.org/10.1007%2F3-540-45319-9_1).
2.  **[^](https://en.wikipedia.org/wiki/Computation_tree_logic#cite_ref-2 "Jump up")** David, Amélie; Laroussinie, Francois; Markey, Nicolas (2016). Desharnais, Josée; Jagadeesan, Radha (eds.). ["On the Expressiveness of QCTL"](http://drops.dagstuhl.de/opus/volltexte/2016/6164). _27th International Conference on Concurrency Theory (CONCUR 2016)_. Leibniz International Proceedings in Informatics (LIPIcs). **59**. Dagstuhl, Germany: Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik: 28:1–28:15. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.4230/LIPIcs.CONCUR.2016.28](https://doi.org/10.4230%2FLIPIcs.CONCUR.2016.28). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [978-3-95977-017-0](https://en.wikipedia.org/wiki/Special:BookSources/978-3-95977-017-0 "Special:BookSources/978-3-95977-017-0").
3.  **[^](https://en.wikipedia.org/wiki/Computation_tree_logic#cite_ref-3 "Jump up")** Hossain, Akash; Laroussinie, François (2019). Gamper, Johann; Pinchinat, Sophie; Sciavicco, Guido (eds.). ["From Quantified CTL to QBF"](http://drops.dagstuhl.de/opus/volltexte/2019/11369). _26th International Symposium on Temporal Representation and Reasoning (TIME 2019)_. Leibniz International Proceedings in Informatics (LIPIcs). **147**. Dagstuhl, Germany: Schloss Dagstuhl–Leibniz-Zentrum fuer Informatik: 11:1–11:20. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.4230/LIPIcs.TIME.2019.11](https://doi.org/10.4230%2FLIPIcs.TIME.2019.11). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [978-3-95977-127-6](https://en.wikipedia.org/wiki/Special:BookSources/978-3-95977-127-6 "Special:BookSources/978-3-95977-127-6"). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [195345645](https://api.semanticscholar.org/CorpusID:195345645).

-   E.M. Clarke; E.A. Emerson (1981). ["Design and synthesis of synchronisation skeletons using branching time temporal logic"](https://www.cs.cmu.edu/afs/cs/user/emc/www/papers/Invited%20Conference%20Articles/Design%20and%20Synthesis%20of%20Synchronization%20Skeletons%20Using%20Branching%20Time%20Temporal%20Logic.pdf) (PDF). _Logic of Programs, Proceedings of Workshop, Lecture Notes in Computer Science_. Lecture Notes in Computer Science. **131**. Springer, Berlin: 52–71. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1007/BFb0025774](https://doi.org/10.1007%2FBFb0025774). [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [3-540-11212-X](https://en.wikipedia.org/wiki/Special:BookSources/3-540-11212-X "Special:BookSources/3-540-11212-X").
-   Michael Huth; Mark Ryan (2004). _Logic in Computer Science_ (Second ed.). Cambridge University Press. p. 207. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [978-0-521-54310-1](https://en.wikipedia.org/wiki/Special:BookSources/978-0-521-54310-1 "Special:BookSources/978-0-521-54310-1").
-   Emerson, E. A.; [Halpern, J. Y.](https://en.wikipedia.org/wiki/Joseph_Halpern "Joseph Halpern") (1985). "Decision procedures and expressiveness in the temporal logic of branching time". _[Journal of Computer and System Sciences](https://en.wikipedia.org/wiki/Journal_of_Computer_and_System_Sciences "Journal of Computer and System Sciences")_. **30** (1): 1–24. [CiteSeerX](https://en.wikipedia.org/wiki/CiteSeerX_(identifier) "CiteSeerX (identifier)") [10.1.1.221.6187](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.221.6187). [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1016/0022-0000(85)90001-7](https://doi.org/10.1016%2F0022-0000%2885%2990001-7).
-   Clarke, E. M.; Emerson, E. A. & Sistla, A. P. (1986). ["Automatic verification of finite-state concurrent systems using temporal logic specifications"](https://doi.org/10.1145%2F5397.5399). _[ACM Transactions on Programming Languages and Systems](https://en.wikipedia.org/wiki/ACM_Transactions_on_Programming_Languages_and_Systems "ACM Transactions on Programming Languages and Systems")_. **8** (2): 244–263. [doi](https://en.wikipedia.org/wiki/Doi_(identifier) "Doi (identifier)"):[10.1145/5397.5399](https://doi.org/10.1145%2F5397.5399). [S2CID](https://en.wikipedia.org/wiki/S2CID_(identifier) "S2CID (identifier)") [52853200](https://api.semanticscholar.org/CorpusID:52853200).
-   Emerson, E. A. (1990). "Temporal and modal logic". In [Jan van Leeuwen](https://en.wikipedia.org/wiki/Jan_van_Leeuwen "Jan van Leeuwen") (ed.). _Handbook of Theoretical Computer Science, vol. B_. MIT Press. pp. 955–1072. [ISBN](https://en.wikipedia.org/wiki/ISBN_(identifier) "ISBN (identifier)") [978-0-262-22039-2](https://en.wikipedia.org/wiki/Special:BookSources/978-0-262-22039-2 "Special:BookSources/978-0-262-22039-2").

## External links\[[edit](https://en.wikipedia.org/w/index.php?title=Computation_tree_logic&action=edit&section=16 "Edit section: External links")\]

-   [Teaching slides of CTL](http://www.inf.unibz.it/~artale/FM/slide4.pdf)